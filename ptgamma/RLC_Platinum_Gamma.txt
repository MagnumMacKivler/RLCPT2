@name ptgamma/RLC Platinum Gamma
@inputs Prime1 Prime2 Start1 Start2 Shutdown1 Shutdown2 Isolation1 Isolation2 EngineRun GenField BrakeCutIn CtlTable:table Active Pod:entity Trucks:array SpanBolsters:array UsingRearSeat [FrontPlugIn RearPlugIn FrontCurrentIn RearCurrentIn]:array HandBrakeOverride HEP_Up HEP_Dn Lights_Front Lights_Rear RemoteMode IsolateBrakes Number:string
@outputs RLCPT:entity Primed1 Primed2 PrimerSet1 PrimerSet2 Clag1 Clag2 On1 On2 [FrontPlugOut RearPlugOut FrontCurrentOut RearCurrentOut]:array MU_Master Reverser Throttle Notch Dynamics DynaNotch DynamicBrakingPower SelectorNotch Emergency V MPH KPH Load1 Load2 TE_LBF Voltage TransitionNotch EngineNotch1 EngineNotch2 EngineSpeed1 EngineSpeed2
@outputs MainRes EqualRes BrakePipe BrakeCyl Cyl CFM LocoBrakePressure BrakeNotch LocoBrakeNotch Bleeding CarCount TrainWeight MU_F MU_R WheelSlip BrakeWarn ForceSand HEP_Notch Lights_Forward Lights_Backward Lights_Fwd_RGB:vector Lights_Back_RGB:vector AirBrakeMode InitialReduction
@outputs AvCurrent GenCurrent Currents:array
#Engine Config
@persist DPM HEP HEP_Subtract HEPTYPE StartupClagDelay StartupClagDuration Startup_Mode Shutdown_Mode FuelSaverMode FuelSaverDelay NumThrottleNotches NumEngineNotches PrimerDuration
#Engine Sounds
@persist [Startup_Hi Startup_Lo Shutdown_Hi Shutdown_Lo TransitionPath TransitionToLow TransitionToHigh Idle_Low]:string [Notches EngineBehavior UpDelays DownDelays]:array
#Engine Data
@persist On1 On2 Primed1 Primed2 Priming1 Priming2 Starting1 Starting2 LowIdleCondition1 LowIdleCondition2 LowIdling1 LowIdling2 LowIdleWaiting1 LowIdleWaiting2 EngineNotch1 EngineNotch2 EngineSpeed1 EngineSpeed2 Throttle Notch HumpMultiplier
@persist RevDirection1 RevDirection2 TimeStamp1 TimeStamp2 Dur1 Dur2 NQ TQ1 TQ2 ABQ1 ABQ2 ABlendQ1 ABlendQ2 AnyBlendQ1 AnyBlendQ2 LRQ1 LRQ2 RevQ TransitionNotch TE_Starting Power HEP_Notch HEPQ HEPCLAG HEPTHROTTLEBASE TE Force Load_Setpoint Load
#New Traction Stuff
@persist TransitionGroups:array TransitionShunts:array GeneratorTransition NominalVoltage MaxGenCurrent TransitionNotches TransitionThresholds:array GenThreshold
@persist TM_Temp TM_Warning TM_Health TM_Damage TM_ZapQ TM_Maxtime TM_Mintime
#Locomotive Config
@persist Horsepower Weight Adhesion Axles Motors MotorType MaxLoad MaxContLoad AirBrakeMode DynamicsMode MaxDynLoad DB_Throttle LimitCurrent BlendedBraking [Controls Routing]:table Shift:string NotchedThrottle
@persist BaseSpeed TopSpeed ClaspBrakes TractionMode LoadRampSpeed WeightOnAxle
@persist TransitionMode TransitionVoltage TransitionControlType TransitionQ
@persist StarterMode OverloadProtection OLPR OLP_Engaged Compressor_CFM MainResVolume
#Locomotive Sounds
@persist [PrimeOn PrimeOff Lever_Throttle Lever_HandBrake RollSoundWelded RollSoundJointed TractionDrone MotorDamaging MotorDeath DynamicsDeath Dynamics_Fubar_On Dynamics_Fubar_Off]:string
@persist [WheelSlipOn WheelSlipOff WheelSlide SanderOn SanderOff Button_HEP]:string
#Brake Sounds
@persist [AirBrakeDump CompressorOn CompressorOff BrakeSqueal]:string
@persist [DynamicsOn DynamicsOff]:string 
#Brake Data
@persist BrakeMul MainRes EqualRes BrakePipe BrakeCyl LocoBrakePressure BRQ PropCount MaxTrainBrakeForce BrakeNotch ABQ LBQ CarCount HissQ LHissQ Suppression InitialReduction
@persist Dynamics DynaNotch DynamicBrakingPower DB_Level NotchedDynamics DNQ BrakeWarning CompQ1 CompQ2 SquealQ BHQ BAQ HandBrakeQ CPitch BleedPressure Bleeding Lock_26L HoldingQ HoldingPressure
@persist DB_Temp DB_Warning DB_Damage DB_Maxtime DB_Mintime
@persist GraduatedRelease FeedPressure AuxRes EmRes AuxMaxPressure SlideQ
#Controls
@persist SetReverser SetThrottle SetDynamics SetSelector IncreaseTrainBrake DecreaseTrainBrake IncreaseLocoBrake DecreaseLocoBrake HandBrake SandQ
#Misc
@persist [E O W H1 H2]:entity DriverQ RailType RollQ LastProps:array MU_Connected MU_F MU_R WheelSlip WheelSlipLocal WheelSlipRand Sanding APR ForceSand WheelSlipThreshold Reverser_DPM DPM_Delay
@persist RemoteMode ForcePrime1 ForcePrime2 ForceStart1 ForceStart2 SoundMultiplier HasPM HasTM SlugMode DroneQ HeadlightRGB:vector WillItBlend SwitchingMode
@persist [CFG_Version ENG_Version CS_Version]:string
@persist AC_PlugNope MU_Master CtlInitQ [FrontTruck RearTruck]:entity ClicketyQ

@trigger Prime1 Prime2 Start1 Start2 Isolation1 Isolation2 EngineRun GenField
@model models/cheeze/beta/white_button.mdl

#To-Do for 59

#Actual Blended Braking God Please Kill Me

#Finished:

#Display Names & Versions for Control Stand E2s [x]
#Abusable Dynamic Brakes [x]
#Jointed Rail [x]
#Re-Add Single-Speed DB cooling and DB limiting [x]
#Wheel Lockup when using Independents + Dynamics [x]
#Fix the Cstand thinking PT commands are invalid and vice versa [x]
#Fix Control Stands Locomotive Brakes [x]
#Primer Durations [x]
#Graduated Release + Brake Control Redo [x]
#Engine Sound Blending [x]
#Shutdown Button [x]
#Hump Control HHHHHHHH [x]
#Add new horn cord code into the other stands (already in KC92) [x]
#Fix AB/LB Set on control stands [x]
#Fix Gen Field not MU-ing properly [x]
#No. 6 Air Brakes [x]
#Dual Control Stand MUX [x]
#Air Compressor Nerf with CFM Config [x]
#Span Bolster Weight Setup [x]
#TE Output in LBF [x]
#Fix Dynamic Braking Cooling Modes [x]
#Rename Brake Cutout to something else [x]
#Fix Desc in Loco Configs for Load Ramp Speed [x]
#Dual Prime Mover - Double Current [x]
#AC Traction Reverser Dynamics Thing [x]
#Auto TM Protection Option [x]
#Auto Starter Inputs [x]
#Pre-Play Soundstop for Control Stands [x]
#HPT sums HP [x]
#Buttonfuck 2018 [x]


if(first()|dupefinished()){
    
    local Version = "Gamma 2.0.58"
    
    #See the attached Operator's Manual (ptgamma/RLC PT2 Operator Manual.txt) for setup and operation instructions.
    
    #NOTES:
    #1- This E2 REQUIRES GroveStreetGman's Train Sounds to function, due to a quirk involving sound timing. If for some reason you don't have it, you can find it here:
    #http://steamcommunity.com/sharedfiles/filedetails/?id=240020348
    #2- Do not use any Default (Non-Workshop-Addon) sounds for the engine (Cab/Lever Sounds are OK). Not that you would be doing this anyway, but it would break sound timing.
    
    #LOCOMOTIVE CONFIG
    
    #What locomotive do you want RLC PT2 to emulate? Look in "ptgamma/locos/" !
    #include "ptgamma/locos/generic/emd_sd40"
    
    #That's pretty much all the config!
    
    #MISC SOUNDS
    
    Lever_Throttle = "gsgtrainsounds/misc/switch_rotating.wav"
    
    Lever_HandBrake = "buttons/lever4.wav"
    
    Button_HEP = "gsgtrainsounds/misc/switch_rotating.wav"
    
    SanderOn = "gsgtrainsounds/misc/airbrakes/air_sander_loop.wav"
    SanderOff = "gsgtrainsounds/misc/airbrakes/air_sander_end.wav"
    
    AirBrakeDump = "gsgtrainsounds/misc/airbrakes/air_dump.wav"
    
    BrakeSqueal = "gsgtrainsounds/wheels/brake_3_loud.wav"
    RollSoundWelded = "gsgtrainsounds/misc/wheels_welded.wav"
    RollSoundJointed = "gsgtrainsounds/misc/wheels_jointed.wav"
    
    RailType = 0 #0 for Continuous Welded Rail, 1 for Jointed (Jointed doesn't do anything yet!)
    
    WheelSlipOn = "gsgtrainsounds/wheels/wheelslip_loop.wav"
    WheelSlipOff = "gsgtrainsounds/wheels/wheelslip_end.wav"
    WheelSlide = "physics/metal/canister_scrape_smooth_loop1.wav"
    
    TractionDrone = "gsgtrainsounds/wheels/emd_dr77_traction.wav"
    MotorDamaging = "ambient/energy/electric_loop.wav"
    MotorDeath = "npc/ministrider/flechette_explode3.wav"
    
    DynamicsDeath = "ambient/explosions/explode_3.wav"
    Dynamics_Fubar_On = "gsgtrainsounds/misc/electrical_arking.wav"
    Dynamics_Fubar_Off = "ambient/energy/spark1.wav"
    
    #INITIALIZATION
    
    #Sound Index Register
    #0 - Prime Mover 1
    #1 - Prime Mover 2
    #2 - Fuel Pump 1/TM Drone
    #3 - Fuel Pump 2/Cab Levers
    #4 - Brake Hiss
    #5 - Dynamic Brake Fans
    #6 - Brake Screech
    #7 - Wheel Rolling
    #8 - Air Compressor 1
    #9 - Air Compressor 2
    #10 - LoI Counter 1
    #11 - LoI Counter 2
    #12 - WheelSlip
    #13 - Sander
    #14 - Traction Motor Death Throes
    
    
    #MU Info Register
    #1 - Reverser
    #2 - Throttle
    #3 - Dynamic Brake
    #4 - Main Reservoir
    #5 - Locomotive Brake
    #6 - MU Master Heartbeat
    #7 - Horsepower
    #8 - Total Effective Units
    #9 - Compressing
    #10 - Headlight
    #11 - "Heartbeat"
    #12 - Sand
    #13 - TransitionNotch
    #14 - Wheel Slip
    #15 - Loco Weights (LB)
    #16 - Total Compressor CFM
    #17 - Hump Multiplier
    #18 - Total Main Res Volume
    #19 - Brake Warning
    
    
    #Config Init
    
    function void ctlTableInit(){
        AirBrakeMode = CtlTable["AirBrakeMode",number]
        InitialReduction = CtlTable["InitialReduction",number] 
        NotchedThrottle = CtlTable["NotchedThrottle",number]
        NumThrottleNotches = CtlTable["NumThrottleNotches",number]
        NotchedDynamics = CtlTable["NotchedDynamics",number]
        TransitionMode = CtlTable["TransitionMode",number]
        TransitionControlType = CtlTable["TransitionControlType",number]
        return void
    }
    
    #Loco
    local LastCompatibleConfig = "2.0.57"
    local RLCVA = LastCompatibleConfig:explode(".")
    local RLCV_Major = RLCVA[2,string]
    local RLCV_Minor = RLCVA[3,string]
    
    local CFGVA = CFG_Version:explode(".")
    local CFGV_Major = CFGVA[2,string]
    local CFGV_Minor = CFGVA[3,string]
    
    local CFG_Conflict = (RLCV_Major != CFGV_Major) | (CFGV_Minor:toNumber() < RLCV_Minor:toNumber())
    
    #Engine
    LastCompatibleConfig = "2.0.56"
    RLCVA = LastCompatibleConfig:explode(".")
    RLCV_Major = RLCVA[2,string]
    RLCV_Minor = RLCVA[3,string]
    
    local ENGVA = ENG_Version:explode(".")
    local ENGV_Major = ENGVA[2,string]
    local ENGV_Minor = ENGVA[3,string]
    
    local ENG_Conflict = (RLCV_Major != ENGV_Major) | (ENGV_Minor:toNumber() < RLCV_Minor:toNumber())
    
    #Control Stand
    LastCompatibleConfig = "2.0.57"
    RLCVA = LastCompatibleConfig:explode(".")
    RLCV_Major = RLCVA[2,string]
    RLCV_Minor = RLCVA[3,string]
    
    CS_Version = CtlTable["CS_Version",string]
    local CSVA = CS_Version:explode(".")
    local CSV_Major = CSVA[2,string]
    local CSV_Minor = CSVA[3,string]
    
    local CS_Conflict = ->CtlTable ? (RLCV_Major != CSV_Major) | (CSV_Minor:toNumber() < RLCV_Minor:toNumber()) : 0
    
    #Controls
    LastCompatibleConfig = "2.0.56"
    RLCVA = LastCompatibleConfig:explode(".")
    RLCV_Major = RLCVA[2,string]
    RLCV_Minor = RLCVA[3,string]
    
    CTL_Version = CtlTable["CTL_Version",string]
    local CTLVA = CTL_Version:explode(".")
    local CTLV_Major = CTLVA[2,string]
    local CTLV_Minor = CTLVA[3,string]
    
    local CTL_Conflict = ->CtlTable ? (RLCV_Major != CTLV_Major) | (CTLV_Minor:toNumber() < RLCV_Minor:toNumber()) : 0
    
    if(CFG_Conflict | ENG_Conflict | CS_Conflict | CTL_Conflict){
        printColor(vec(0,191,255),"[RLCPT] Note: One of your configs are out of date! Please use configs compatible with ",vec(255),Version+"!\n--------")
        printColor("Engine Config version: ",ENG_Conflict ? vec(255,0,0) : vec(63,255,63),(ENG_Version=="") ? "unknown" : ENG_Version)
        printColor("Locomotive Config version: ",CFG_Conflict ? vec(255,0,0) : vec(63,255,63),(CFG_Version=="") ? "unknown" : CFG_Version)
        if(->CtlTable){
            printColor("Control Stand/Reader version: ",CS_Conflict ? vec(255,0,0) : vec(63,255,63),(CS_Version=="") ? "unknown" : CS_Version)
            printColor("Control Config version: ",CTL_Conflict ? vec(255,0,0) : vec(63,255,63),(CTL_Version=="") ? "unknown" : CTL_Version)
        }else{
            printColor("Control Config and Control Stand/Reader version unknown. Please refresh RLC PT2 after wiring.")
        }
        
        soundPlay(0,0,"buttons/blip2.wav")
        owner():soundPlay(1,0,"vo/engineer_moveup01.mp3")
        setName("RLC Platinum " + Version + "\nPlease Update Config(s)!")
        exit()
    }elseif(->CtlTable){
        ctlTableInit()
    }else{
        printColor(vec(255,191,0),"[RLCPT] Error: Cannot find CtlTable! Please reload E2 when CtlTable is wired.")
        soundPlay(0,0,"buttons/button3.wav")
        setName("RLC Platinum " + Version + "\nPlease see Operator's Manual for Setup Instructions!")
        exit()
    }
    
    #Startup Init
    On1 = On2 = 0
    Primed1 = Primed2 = 0
    Priming1 = Priming2 = 0
    
    Starting1 = Starting2 = 0
    
    Clag1 = 0
    Clag2 = 0
    LowIdling1 = 0
    LowIdling2 = 0
    
    E = entity()
    RLCPT = E
    O = owner()
    W = E:isWeldedTo()
    H1 = holoCreate(1,W:boxCenterW())
    holoParent(1,W)
    holoAlpha(1,0)
    H2 = holoCreate(2,W:boxCenterW())
    holoParent(2,W)
    holoAlpha(2,0)
    
    #Engine Init
    Throttle = 0
    DynamicBrake = 0
    HumpMultiplier = 1
    TQ1 = 0
    TQ2 = 0
    ABQ1 = 0
    ABQ2 = 0
    EngineSpeed1 = EngineSpeed2 = 0
    EngineNotch1 = EngineNotch2 = 0
    LRQ1 = LRQ2 = 0
    RevQ = 0
    LowIdleWaiting1 = 0
    
    ForcePrime1 = 0
    ForcePrime2 = 0
    ForceStart1 = 0
    ForceStart2 = 0
    
    DPM_Delay = 300
    
    NominalVoltage = 3000
    
    TransitionNotch = 0
    TransitionQ = 0
    HEP_Notch = 0
    HEPCLAG = 0
    HEPTHROTTLEBASE = 0
    
    local InitGrp = TransitionGroups[1,number]
    local InitSnt = TransitionShunts[1,number]
    TransitionGroups:unshiftNumber(InitGrp)
    TransitionShunts:unshiftNumber(InitSnt)
    
    #   -4X^2 + 4NomX - 746*HP = 0
    #   -0.25X^2 + MaxX - 746*HP = 0
    
    TransitionVoltage = ( -(4*NominalVoltage) - sqrt((4*NominalVoltage)^2 - 4*4*746*Horsepower) )/(2*-4)
    
    TransitionNotches = TransitionGroups:count() - 1
    
    for(N=1,TransitionNotches-1){
        TransitionThresholds[N+1,number] = TransitionVoltage*TopSpeed/(NominalVoltage*TransitionShunts[N+1,number]*TransitionGroups[N+1,number])
    }

    #Generator Transition
    if(GeneratorTransition){
        GenThreshold = TransitionVoltage*TopSpeed/(NominalVoltage*TransitionShunts[2,number]*TransitionGroups[2,number]*2.5)
    }
    
        
    #MU Init
    FrontPlugOut = array(
        0,
        0,
        0,
        0,
        0,
        1,
        Horsepower
    )
    RearPlugOut = FrontPlugOut:clone()
    
    NQ = 0
    
    #Brake Init
    BrakeMul = 775*2
    MainRes = 0
    EqualRes = 0
    BrakePipe = 0
    BrakeCyl = 90
    LocoBrakePressure = 0
    ABQ = 0
    LBQ = 0
    LocoBrakeNotch = 0
    BleedPressure = 72
    Lock_26L = 0
    
    FeedPressure = 90
    
    Suppression = 0
    HissQ = 0
    LHissQ = 0
    
    BHQ = 0
    BAQ = 0
    BRQ = 0
    
    HandBrakeQ = 0
    
    CompQ1 = CompQ2 = 0
    CPitch = 20
    
    CarCount = 0
    
    MaxTrainBrakeForce = 0
    
    if(AirBrakeMode==2){#26L
        BrakeNotch = 2
    }elseif((AirBrakeMode==3)|(AirBrakeMode==4)){#24RL/No6
        BrakeNotch = 4 
        #print("Yarg")   
    }elseif(AirBrakeMode==1){#Simple ML
        BrakeNotch = 2
    }else{ #Simple SL
        BrakeNotch = 0
    }
    
    #Dynamic Brake Init
    
    Dynamics = 0
    DynamicBrakingPower = 0
    DynaNotch = -1
    DNQ = 0
    Dynamics = 0
    DB_Level = 50
    
    #Misc Init
    
    #0 - Locomotive
    #1 - Slug (No Prime Mover, has Traction Motors
    #2 - Snail (No Traction Motors, has Prime Mover
    #3 - Cab Car/Control Cab (No Traction Motors or Prime Mover)
    HasPM = (UnitType==0) | (UnitType==2)
    HasTM = (UnitType==0) | (UnitType==1)
    SlugMode = UnitType==1
    if(!HasPM){
        DPM = 0
        HEP = 0
        #print("AAAA")
    }
    WeightOnAxle = Weight/Axles
    TE_Starting = WeightOnAxle*Adhesion
    
    TM_Maxtime = 30
    TM_Mintime = 1
    TM_Health = 100
    
    DB_Maxtime = 30
    DB_Mintime = 1
    DB_Health = 100
    
    #1.016 sec
    
    SoundMultiplier = soundDuration("gsgtrainsounds/misc/switch_rotating.wav")/0.645
    
    RollQ = 0
    DroneQ = 0
    WheelSlipRand = 0
    APR = 1
    LoadingControls = 0
    E:setSubMaterial(2,"debug/env_cubemap_model")
    runOnChat(1)
    setName("RLC Platinum " + Version + "\n" + EngineType + "\n" + LocomotiveType)
    
    local MaxDot = 0
    local MinDot = 0
    foreach(K,V:entity=Trucks){
        local Dot = (V:pos()-W:pos()):dot(-E:up())
        #print(Dot)
        if(Dot>MaxDot){
            MaxDot = Dot
            FrontTruck = V
        }elseif(Dot<MinDot){
            MinDot = Dot
            RearTruck = V
        }
    }
    #print("Front:"+FrontTruck:toString())
    #print("Rear:"+RearTruck:toString())
    
    
    #DPM Init
    
    if(DPM){
        Horsepower = Horsepower/2
        MaxGenCurrent = MaxGenCurrent/2
        Motors = Motors/2
    }
    
    #CUSTOM FUNCTIONS
    function number sdr(Soundpath:string){
        #local Tick = round(1/tickInterval())
        
        DR = floor(soundDuration(Soundpath)*100/SoundMultiplier)*10 - 20
        #print(DR)
        return DR
    }
    
    function normal adc(MinVal, MaxVal, Resolution, Input){
        local Output = 0
        if(inrange(Input,MinVal,MaxVal)){
            Output = round(Resolution*((Input - MinVal)/(MaxVal-MinVal)))
            
        }elseif(Input < MinVal){
            Output = 0
        }elseif(Input > MaxVal){
            Output = Resolution
        }
        
        return Output
    }
    
    function normal dac(MinVal, MaxVal, Resolution, Input){
        local Output = 0
        if(inrange(Input,0,Resolution)){
            Input = round(Input)
            Output = (MaxVal - MinVal)*(Input/Resolution) + MinVal
        }elseif(Input < 0){
            Output = MinVal
        }elseif(Input > Resolution){
            Output = MaxVal
        }
        return Output
    }
    
    function void transitionUp1(From,To){
        local BType = EngineBehavior[From+1,number]
        local TimeLeftMS = 0
        if(ABlendQ1){
            ABlendQ1 = 0
            To = To - 1
        }
        if((RevDirection1==-1) & !AnyBlendQ1){ #Blend Down to Up
            AnyBlendQ1 = 1
            local ElapsedMS = round((curtime() - TimeStamp1)*100)*10
            TimeLeftMS = Dur1 - ElapsedMS
            soundVolume(0,0,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
            ABQ1 = 1
        }
        switch(BType){
            case 0,
                if(ABQ1){
                    local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+"b.wav"
                    Dur1 = sdr(Snd)
                    TimeStamp1 = curtime()
                    if(TimeLeftMS>0){
                        H1:soundPlay(10,0,Snd)
                        soundVolume(10,0)
                        soundVolume(10,1,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
                    }else{
                        soundStop(10)
                        H1:soundPlay(0,0,Snd)
                    }
                    if((To>(From+1)) & (EngineBehavior[From+2,number]==0)){
                        timer("TQU1",UpDelays[From+1,number])
                    }else{
                        timer("TQU1",sdr(Snd))
                        ABQ1 = 0
                    }
                    EngineSpeed1++
                    if(CompQ1 & !CompressorType){
                        local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                        soundPitch(8,CompressorPitch,sdr(Snd)/1000)
                        #print(CompressorPitch)
                    }
                    RevDirection1 = 1
                    #print("BBB")
                }else{
                    ABQ1 = 1
                    local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+"a.wav"
                    Dur1 = sdr(Snd)
                    TimeStamp1 = curtime()
                    H1:soundPlay(0,0,Snd)
                    timer("TQU1",sdr(Snd))
                    #print("AAA" + sdr(Snd))
                    RevDirection1 = 0
                    ABlendQ1 = 1
                }
                Clag1 = 1
                LRQ1 = 1
                break
            case 1,
                local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+".wav"
                Dur1 = sdr(Snd)
                TimeStamp1 = curtime()
                if(TimeLeftMS>0){
                    H1:soundPlay(10,0,Snd)
                    soundVolume(10,0)
                    soundVolume(10,1,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
                }else{
                    soundStop(10)
                    H1:soundPlay(0,0,Snd)
                }
                timer("TQU1",sdr(Snd))
                EngineSpeed1++
                LRQ1 = 1
                if(CompQ1 & !CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch,sdr(Snd)/1000)
                }
                Clag1 = 1
                RevDirection1 = 1
                break
            case 2,
                TQ1 = 0
                if(!LRQ1){
                    H1:soundPlay(0,0,Notches[From+2,string])
                    soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
                }
                EngineSpeed1++
                if(CompQ1 & !CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch,1)
                }
                RevDirection1 = 0
                break
            case 3,
                EngineSpeed1++
                TQ1 = 0
                if(LRQ1 & (EngineSpeed1==EngineNotch1)){
                    LRQ1 = 0
                    H1:soundPlay(0,0,Notches[EngineSpeed1+1,string])
                    soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
                }
                RevDirection1 = 0
                break
        }
        stoptimer("TQD1")
        return void
    }
    function void transitionUp2(From,To){
        local BType = EngineBehavior[From+1,number]
        local TimeLeftMS = 0
        if(ABlendQ2){
            ABlendQ2 = 0
            To = To - 1
        }
        if((RevDirection2==-1) & !AnyBlendQ2){ #Blend Down to Up
            AnyBlendQ2 = 1
            local ElapsedMS = round((curtime() - TimeStamp2)*100)*10
            TimeLeftMS = Dur2 - ElapsedMS
            soundVolume(1,0,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
            ABQ2 = 1
        }
        switch(BType){
            case 0,
                if(ABQ2){
                    local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+"b.wav"
                    Dur2 = sdr(Snd)
                    TimeStamp2 = curtime()
                    if(TimeLeftMS>0){
                        H2:soundPlay(11,0,Snd)
                        soundVolume(11,0)
                        soundVolume(11,1,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
                    }else{
                        soundStop(11)
                        H2:soundPlay(1,0,Snd)
                    }
                    if((To>(From+1)) & (EngineBehavior[From+2,number]==0)){
                        timer("TQU2",UpDelays[From+1,number])
                    }else{
                        timer("TQU2",sdr(Snd))
                        ABQ2 = 0
                    }
                    EngineSpeed2++
                    if(CompQ2 & !CompressorType){
                        local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                        soundPitch(9,CompressorPitch,sdr(Snd)/1000)
                        #print(CompressorPitch)
                    }
                    RevDirection2 = 1
                }else{
                    ABQ2 = 1
                    local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+"a.wav"
                    Dur2 = sdr(Snd)
                    TimeStamp2 = curtime()
                    H2:soundPlay(1,0,Snd)
                    timer("TQU2",sdr(Snd))
                    RevDirection2 = 0
                    ABlendQ2 = 1
                }
                Clag2 = 1
                LRQ2 = 1
                break
            case 1,
                local Snd = TransitionPath+"up/"+From:toString()+"-"+(From+1):toString()+".wav"
                Dur2 = sdr(Snd)
                TimeStamp2 = curtime()
                if(TimeLeftMS>0){
                    H2:soundPlay(11,0,Snd)
                    soundVolume(11,0)
                    soundVolume(11,1,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
                }else{
                    soundStop(11)
                    H2:soundPlay(1,0,Snd)
                }
                timer("TQU2",sdr(Snd))
                EngineSpeed2++
                LRQ2 = 1
                if(CompQ2 & !CompressorType){
                    local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                    soundPitch(9,CompressorPitch,sdr(Snd)/1000)
                }
                Clag2 = 1
                RevDirection2 = 1
                break
            case 2,
                TQ2 = 0
                if(!LRQ2){
                    H2:soundPlay(1,0,Notches[From+2,string])
                    soundPitch(1,98)
                }
                EngineSpeed2++
                if(CompQ2 & !CompressorType){
                    local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                    soundPitch(9,CompressorPitch,1)
                }
                RevDirection2 = 0
                break
            case 3,
                EngineSpeed2++
                TQ2 = 0
                if(LRQ2 & (EngineSpeed2==EngineNotch2)){
                    LRQ2 = 0
                    H2:soundPlay(1,0,Notches[EngineSpeed2+1,string])
                    soundPitch(1,98,1)
                }
                RevDirection2 = 0
                break
        }
        stoptimer("TQD2")
        return void
    }
    function void transitionDown1(From,To){
        Clag1 = 0
        local BType = EngineBehavior[From,number]
        local TimeLeftMS = 0
        if(ABlendQ1){
            ABlendQ1 = 0
            To = To + 1
        }
        #print("From "+From+" To "+To)
        if((RevDirection1==1) & !AnyBlendQ1){ #Blend Up to Down
            AnyBlendQ1 = 1
            local ElapsedMS = round((curtime() - TimeStamp1)*100)*10
            TimeLeftMS = Dur1 - ElapsedMS
            soundVolume(0,0,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
            ABQ1 = 1
            #print(BType,ABQ1,TimeLeftMS)
        }
        switch(BType){
            case 0,
                if(ABQ1){
                    local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+"b.wav"
                    Dur1 = sdr(Snd)
                    TimeStamp1 = curtime()
                    if(TimeLeftMS>0){
                        H1:soundPlay(10,0,Snd)
                        soundVolume(10,0)
                        soundVolume(10,1,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
                        #print("YEAH")
                    }else{
                        soundStop(10)
                        H1:soundPlay(0,0,Snd)
                        #print("NOPE")
                    }
                    if((To<(From-1)) & (EngineBehavior[From-1,number]==0)){
                        #print("TF "+((To<(From-1))))
                        #print("EB "+(EngineBehavior[From-1,number]==0))
                        timer("TQD1",DownDelays[8-From+1,number])
                        #print("Play B Cont")
                    }else{
                        timer("TQD1",sdr(Snd))
                        #print("Play B Final")
                        ABQ1 = 0
                    }
                    EngineSpeed1--
                    if(CompQ1 & !CompressorType){
                        local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                        soundPitch(8,CompressorPitch,sdr(Snd)/1000)
                    }
                    RevDirection1 = -1
                }else{
                    ABQ1 = 1
                    local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+"a.wav"
                    Dur1 = sdr(Snd)
                    TimeStamp1 = curtime()
                    H1:soundPlay(0,0,Snd)
                    timer("TQD1",sdr(Snd))
                    #print("Play A")
                    RevDirection1 = 0
                    ABlendQ1 = -1
                }
                LRQ1 = 1
                break
            case 1,
                local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+".wav"
                Dur1 = sdr(Snd)
                TimeStamp1 = curtime()
                if(TimeLeftMS>0){
                    H1:soundPlay(10,0,Snd)
                    soundVolume(10,0)
                    soundVolume(10,1,clamp(TimeLeftMS/1000,0,(Dur1/1000)-0.001))
                }else{
                    soundStop(10)
                    H1:soundPlay(0,0,Snd)
                }
                timer("TQD1",sdr(Snd))
                EngineSpeed1--
                LRQ1 = 1
                if(CompQ1 & !CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch,sdr(Snd)/1000)
                }
                RevDirection1 = -1
                break
            case 2,
                TQ1 = 0
                if(!LRQ1){
                    H1:soundPlay(0,0,Notches[From,string])
                    soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
                }
                EngineSpeed1--
                if(CompQ1 & !CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch,1)
                }
                RevDirection1 = 0
                break
            case 3,
                EngineSpeed1--
                TQ1 = 0
                if(LRQ1 & (EngineSpeed1==EngineNotch1)){
                    LRQ1 = 0
                    H1:soundPlay(0,0,Notches[EngineSpeed1+1,string])
                    soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
                }
                RevDirection1 = 0
                break
        }
        #print("Yadunfuktupnow!")
        stoptimer("TQU1")
        return void
    }
    function void transitionDown2(From,To){
        Clag2 = 0
        local BType = EngineBehavior[From,number]
        local TimeLeftMS = 0
        if(ABlendQ2){
            ABlendQ2 = 0
            To = To - 1
        }
        if((RevDirection2==1) & !AnyBlendQ2){ #Blend Up to Down
            AnyBlendQ2 = 1
            local ElapsedMS = round((curtime() - TimeStamp2)*100)*10
            TimeLeftMS = Dur2 - ElapsedMS
            soundVolume(1,0,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
            ABQ2 = 1
            #print(BType,ABQ1,TimeLeftMS)
        }
        switch(BType){
            case 0,
                if(ABQ2){
                    local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+"b.wav"
                    Dur2 = sdr(Snd)
                    TimeStamp2 = curtime()
                    if(TimeLeftMS>0){
                        H2:soundPlay(11,0,Snd)
                        soundVolume(11,0)
                        soundVolume(11,1,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
                        #print("YEAH")
                    }else{
                        soundStop(11)
                        H2:soundPlay(1,0,Snd)
                        #print("NOPE")
                    }
                    if((To<(From-1)) & (EngineBehavior[From-1,number]==0)){
                        timer("TQD2",DownDelays[8-From+1,number])
                    }else{
                        timer("TQD2",sdr(Snd))
                        ABQ2 = 0
                    }
                    EngineSpeed2--
                    if(CompQ2 & !CompressorType){
                        local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                        soundPitch(9,CompressorPitch,sdr(Snd)/1000)
                    }
                    RevDirection2 = -1
                }else{
                    ABQ2 = 1
                    local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+"a.wav"
                    Dur2 = sdr(Snd)
                    TimeStamp2 = curtime()
                    H2:soundPlay(1,0,Snd)
                    timer("TQD2",sdr(Snd))
                    RevDirection2 = 0
                    ABlendQ2 = -1
                }
                LRQ2 = 1
                break
            case 1,
                local Snd = TransitionPath+"down/"+From:toString()+"-"+(From-1):toString()+".wav"
                Dur2 = sdr(Snd)
                TimeStamp2 = curtime()
                if(TimeLeftMS>0){
                    H2:soundPlay(11,0,Snd)
                    soundVolume(11,0)
                    soundVolume(11,1,clamp(TimeLeftMS/1000,0,(Dur2/1000)-0.001))
                }else{
                    soundStop(11)
                    H2:soundPlay(1,0,Snd)
                }
                timer("TQD2",sdr(Snd))
                EngineSpeed2--
                LRQ2 = 1
                if(CompQ2 & !CompressorType){
                    local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                    soundPitch(9,CompressorPitch,sdr(Snd)/1000)
                }
                RevDirection2 = -1
                break
            case 2,
                TQ2 = 0
                if(!LRQ2){
                    H2:soundPlay(1,0,Notches[From,string])
                    soundPitch(1,98,1)
                }
                EngineSpeed2--
                if(CompQ2 & !CompressorType){
                    local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                    soundPitch(9,CompressorPitch,1)
                }
                RevDirection2 = 0
                break
            case 3,
                EngineSpeed2--
                TQ2 = 0
                if(LRQ2 & (EngineSpeed2==EngineNotch2)){
                    LRQ2 = 0
                    H2:soundPlay(1,0,Notches[EngineSpeed2+1,string])
                    soundPitch(1,98,1)
                }
                RevDirection2 = 0
                break
        }
        #print("Wat")
        stoptimer("TQU2")
        return void
    }
    
    function number carCount(SWM){
        local Cars = 0
        if(SWM){
            Cars = 1
        }else{
            local Props = E:getConstraints()
            local Cnt = 0
            local ImportantProps = array()
            foreach(K,V:entity = Props){
                if(V:mass()>1000){
                    ImportantProps[Cnt,entity] = V
                    Cnt++
                }
            }
            local ExtraProps = ImportantProps:count()
            Cars = floor(ExtraProps/3)
            if(Cars<0){Cars = 0}
            
        }
        MaxTrainBrakeForce = BrakeMul*(Cars-1)*0.475
        if(MaxTrainBrakeForce<0){MaxTrainBrakeForce = 0}
        return Cars
        
    }
    function number trainWeight(){
        local WeightProps = E:getConstraints()
        local TotalMass = 0
        foreach(K,V:entity=WeightProps){
            TotalMass += V:mass()
        }
        return TotalMass
    }
    function void abRelease(){
        local Ents = E:getConstraints()
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("friction_00")
            V:propDrag(0)
        }
        return void
    }
    function void abRest(Ents:array){
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("phx_tire_normal")
        }
        return void
    }
    function void abEmergency(Ents:array){
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("slipperyslime")
        }
        return void
    }
    function void setWeight(Carbody:entity,Bolsters:array,Trucks:array,Pounds){
        local KG = fromUnit("lb",Pounds/2)
        local CarbodyWeight = clamp(round(KG/2),10,50000)
        
        Carbody:setMass(CarbodyWeight)
        KG -= CarbodyWeight
        
        if(Bolsters:count()>0){
            local BolsterWgt = round(KG/(Bolsters:count()*2))
            for(N=1,Bolsters:count()){
                Bolsters[N,entity]:setMass(BolsterWgt)
            }
            KG -= BolsterWgt*Bolsters:count()
        }
        
        
        local TruckWgt = round(KG/Trucks:count())
        for(N=1,Trucks:count()){
            Trucks[N,entity]:setMass(TruckWgt)
        }

        
        return void
    }
    
    function void interrupt(PM){
        if(PM==1){
            stoptimer("startprime1")
            stoptimer("endprime1")
            stoptimer("startstart1")
            stoptimer("endstart1")
            ForceStart1 = 0
            ForcePrime1 = 0
            PrimerSet1 = 0
            #print("Interrupt!")
        }elseif(PM==2){
            stoptimer("startprime2")
            stoptimer("endprime2")
            stoptimer("startstart2")
            stoptimer("endstart2")
            ForceStart2 = 0
            ForcePrime2 = 0
            PrimerSet2 = 0
        }
        return void
    }
    
    function number linterp(T,Start:vector2,End:vector2){ #2-Point Linear Interpolation - Modified for PT2 Traction Motor Consequences
    
        local X0 = Start:x()
        local X1 = End:x()
        local Y0 = Start:y()
        local Y1 = End:y()
        
        if(T>X0){
            local TN = (T-X0)/(X1-X0)
            return Y0 + TN*(Y1-Y0)
        }else{
            return 0
        }
    }
    
    function void entity:printProper(Message:string){
        if(This==O){
            print(Message)
        }else{
            Pod:printDriver(Message)
        }
        return void
    }
    
    setWeight(W,SpanBolsters,Trucks,Weight)
    
    #print(sdr("gsgtrainsounds/alco539t/startup.wav"))
    #print(sdr("gsgtrainsounds/alco539t/shutdown.wav"))
    timer("CarCount",5000)
    timer("clk",100)
}
#Autostart Shenannigans
if(clk("startprime1")){
    ForcePrime1 = 1
    PrimerSet1 = 1
    timer("endprime1",1000*(PrimerDuration+1))
}elseif(clk("endprime1")){
    ForcePrime1 = 0
    timer("startstart1",1000)
}elseif(clk("startstart1")){
    ForceStart1 = 1
    timer("endstart1",StartupClagDelay*1000 + 1000)
}elseif(clk("endstart1")){
    ForceStart1 = 0
}elseif(clk("startprime2")){
    ForcePrime2 = 1
    PrimerSet2 = 1
    timer("endprime2",1000*(PrimerDuration+1))
}elseif(clk("endprime2")){
    ForcePrime2 = 0
    timer("startstart2",1000)
}elseif(clk("startstart2")){
    ForceStart2 = 1
    timer("endstart2",StartupClagDelay*1000 + 1000)
}elseif(clk("endstart2")){
    ForceStart2 = 0
}
if(HasPM){ #Actual Engine Starting
    #Prime 1
    if((Prime1|ForcePrime1) & !Priming1){
        Priming1 = 1
        if(On1){
            stoptimer("PrimeCool1")
        }else{
            
            H1:soundPlay(2,0,PrimeOn)
            timer("PrimeCheck1",1000*(PrimerDuration))
        }
    }elseif(!(Prime1|ForcePrime1) & Priming1){
        Priming1 = 0
        if(On1 & (StarterMode>0)){
            timer("PrimeCool1",15000)
        }else{
            
            H1:soundPlay(2,2,PrimeOff)
            stoptimer("PrimeCheck1")
        }
        #print("Kill me.")
    }
    if(clk("PrimeCheck1")){
        Primed1 = Primed1 ? 1 : Priming1
    }
    
    #Start/Shutdown 1
    if((Start1|ForceStart1) & !Shutdown1){
        if(~Start1 & (StarterMode==2) & !Isolation1 & !On1 & !Starting1){
            timer("startprime1",100)
        }elseif(!On1 & !Starting1 & Primed1 & ((~Start1 & (StarterMode<2))|ForceStart1) & !Isolation1 & ((StarterMode>0) ? Priming1 : 1)){
            Starting1 = 1
            LowIdling1 = !Startup_Mode
            local Snd = Startup_Mode ? Startup_Hi : Startup_Lo
            H1:soundPlay(0,0,Snd)
            stoptimer("PrimeCool1")
            timer("StartCheck1",StartupClagDelay*1000)
            timer("FinishStart1",sdr(Snd))
            #print("Start1")
        }elseif(On1 & ~Start1 & !Isolation1){
            #Deleted
        }
    }elseif((!(Start1|ForceStart1) | Shutdown1) & Starting1 & !Clag1 & !On1 & (StarterMode<2)){
        Starting1 = 0
        soundPitch(0,0,3)
        soundStop(0,3)
        stoptimer("StartCheck1")
        stoptimer("FinishStart1")
        #interrupt(1)
    }elseif((Shutdown1 | !Primed1) & On1){
        On1 = 0
        if(PrimerSet1){PrimerSet1 = 0}
        if(CompQ1){
            CompQ1 = 0
            H1:soundPlay(8,0,CompressorOff)
            #soundPitch(8,100 + Power/2,1)
        }
        if(Prime1){
            #print("Fuel Punp")
            H1:soundPlay(2,0,PrimeOn)
            soundVolume(2,0)
            soundVolume(2,1,3)
        }
        local Snd = ""
        switch(Shutdown_Mode){
            case 0,
                Snd = Shutdown_Lo
                break
            case 1,
                Snd = Shutdown_Hi
                break
            case 2,
                Snd = LowIdling1 ? Shutdown_Lo : Shutdown_Hi
                break
        }
        H1:soundPlay(0,0,Snd)
        stoptimer("IdleDown1")
        #interrupt(1)
        timer("Cool1",sdr(Snd))
    }
    if((ForcePrime1|ForceStart1) & Shutdown1){
        interrupt(1)
    }
    if(clk("StartCheck1") & (Start1|ForceStart1)){
        Clag1 = 1
        
        if(StarterMode>0){
            soundStop(2,3)
            #Priming1 = 0
        }
        timer("EndStartClag1",StartupClagDuration*1000)
            
    }elseif(clk("FinishStart1")){
        #if(FuelSaverMode & !LowIdling1){
        if(0){
            TQ1 = 1
            LowIdling1 = 1
            local Snd = TransitionPath+"down/1-0.wav"
            H1:soundPlay(0,0,Snd)
            timer("FinishStart1",sdr(Snd))
        }else{
            Starting1 = 0
            H1:soundPlay(0,0,LowIdling1 ? Idle_Low : Notches[1,string])
            soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
            
            EngineNotch1 = 0
            EngineSpeed1 = 0
            #stoptimer("clk")
            #timer("clk",100)
        }
    }elseif(clk("EndStartClag1")){
        Clag1 = 0
        On1 = 1
    }elseif(clk("Cool1")){
        soundStop(0)
        timer("PrimeCool1",60000)
    }elseif(clk("PrimeCool1")){
        Primed1 = 0
    }
    
    if(DPM){
            #Prime 2
        if((Prime2|ForcePrime2) & !Priming2){
        Priming2 = 1
        if(On2){
            stoptimer("PrimeCool2")
        }else{
            
            H2:soundPlay(3,0,PrimeOn)
            timer("PrimeCheck2",1000*(PrimerDuration))
        }
    }elseif(!(Prime2|ForcePrime2) & Priming2){
        Priming2 = 0
        if(On2 & (StarterMode>0)){
            timer("PrimeCool2",15000)
        }else{
            
            H2:soundPlay(3,2,PrimeOff)
            stoptimer("PrimeCheck2")
        }
        #print("Kill me.")
    }
        if(clk("PrimeCheck2")){
            Primed2 = Primed2 ? 1 : Priming2
        }
        
        #Start/Shutdown 2
        if((Start2|ForceStart2) & !Shutdown2){
            if(~Start2 & (StarterMode==2) & !Isolation2 & !On2){
                timer("startprime2",100)
            }elseif(!On2 & !Starting2 & Primed2 & ((~Start2 & (StarterMode<2))|ForceStart2) & !Isolation2 & ((StarterMode>0) ? Priming2 : 1)){
                Starting2 = 1
                LowIdling2 = !Startup_Mode
                local Snd = Startup_Mode ? Startup_Hi : Startup_Lo
                H2:soundPlay(1,0,Snd)
                stoptimer("PrimeCool2")
                timer("StartCheck2",StartupClagDelay*1000)
                timer("FinishStart2",sdr(Snd))
                #print("Start1")
            }elseif(On2 & ~Start2 & !Isolation2){
                #Deleted
            }
        }elseif((!(Start2|ForceStart2) | Shutdown2) & Starting2 & !Clag2 & !On2 & (StarterMode<2)){
            Starting2 = 0
            soundPitch(1,0,3)
            soundStop(1,3)
            stoptimer("StartCheck2")
            stoptimer("FinishStart2")
            #interrupt(2)
        }elseif((Shutdown2 | !Primed2) & On2){
            On2 = 0
            if(PrimerSet2){PrimerSet2 = 0}
            if(CompQ2){
                CompQ2 = 0
                H2:soundPlay(9,0,CompressorOff)
                soundPitch(9,105,1)
            }
            if(Prime2){
                #print("Fuel Punp")
                H1:soundPlay(3,0,PrimeOn)
                soundVolume(3,0)
                soundVolume(3,1,3)
            }
            local Snd = ""
            switch(Shutdown_Mode){
                case 0,
                    Snd = Shutdown_Lo
                    break
                case 1,
                    Snd = Shutdown_Hi
                    break
                case 2,
                    Snd = LowIdling2 ? Shutdown_Lo : Shutdown_Hi
                    break
            }
            H2:soundPlay(1,0,Snd)
            stoptimer("IdleDown2")
            #interrupt(2)
            timer("Cool2",sdr(Snd))
            #print("Shutdown2")
        }
        if((ForcePrime2|ForceStart2) & Shutdown2){
            interrupt(2)
        }
        if(clk("StartCheck2") & (Start2|ForceStart2)){
            Clag2 = 1
            if(StarterMode>0){
                soundStop(3,3)
                #Priming2 = 0
            }
            timer("EndStartClag2",StartupClagDuration*1000)
                
        }elseif(clk("FinishStart2")){
            #if(FuelSaverMode & !LowIdling2){
            if(0){
                TQ2 = 1
                LowIdling2 = 1
                local Snd = TransitionPath+"down/1-0.wav"
                H2:soundPlay(1,0,Snd)
                timer("FinishStart2",sdr(Snd))
            }else{
                Starting2 = 0
                H2:soundPlay(1,0,LowIdling2 ? Idle_Low : Notches[1,string])
                soundPitch(1,98,1)
                
                EngineNotch2 = 0
                EngineSpeed2 = 0
                #stoptimer("clk")
                #timer("clk",100)
            }
        }elseif(clk("EndStartClag2")){
            Clag2 = 0
            On2 = 1
        }elseif(clk("Cool2")){
            soundStop(1)
            timer("PrimeCool2",60000)
        }elseif(clk("PrimeCool2")){
            Primed2 = 0
        }
    }
}else{ #Non-PM Starter Toggle
    if(Start1 & ~Start1){
        if(!On1){
            On1 = 1
            EngineNotch1 = 0
            EngineSpeed1 = 0
        }else{
            On1 = 0
            CompQ1 = 0
        }
        H1:soundPlay(0,1,Lever_Throttle)
    }
}
#What is MU_Master?
MU_Master = EngineRun


if(clk("CarCount")){
    CarCount = carCount(SwitchingMode|IsolateBrakes)
    TrainWeight = trainWeight()
    timer("CarCount",5000)
    LastProps = E:getConstraints()
    if(BrakeCutIn & (MainRes>0)){
        MainRes += -0.0625
    }
    WheelSlipRand = random()<0.75
    
}
if(clk("DPM_Rev")){
    if(DPM & On2 & Isolation2){
        Reverser_DPM = Reverser
    }
}
if(clk("DPM_Eng")){
    #print("AAA DPM!")
    if(DPM & On2 & Isolation2){
        EngineNotch2 = EngineNotch1
        
    }
}
if(clk("IdleDown1")){
    LowIdling1 = 1
    LowIdleWaiting1 = 0
    TQ1 = 1
    local Snd = TransitionToLow
    H1:soundPlay(0,0,Snd)
    #print("IdleDown1")
    stoptimer("TQU1")
    timer("TQD1",sdr(Snd))
}
if(clk("IdleDown2")){
    LowIdling2 = 1
    LowIdleWaiting2 = 0
    TQ2 = 1
    local Snd = TransitionToHigh
    H2:soundPlay(1,0,Snd)
    stoptimer("TQU2")
    timer("TQD2",sdr(Snd))
}
if(clk("HandBrake")){
    if(HandBrake){
        abRest(E:getConstraints())
        Pod:soundPlay(3,1,"buttons/lever4.wav")
        Pod:driver():printProper("[RLCPT] Train Handbrakes Tightened!")
        
    }
}
if(clk("motordamage")){
    if(Load>MaxContLoad){
        TM_Damage = 1
    }
}elseif(clk("dbdamage")){
    if(-Load > MaxDynLoad){
        DB_Damage = 1
        W:soundPlay(14,3,DynamicsDeath)
        W:soundPlay(5,0,Dynamics_Fubar_On)
        DynamicsOn = Dynamics_Fubar_On
        DynamicsOff = Dynamics_Fubar_Off
    }
}


MU_Compress = !BrakeCutIn & (FrontPlugIn[9,number] + RearPlugIn[9,number])
MU_F = (FrontPlugIn[11,number])
MU_R = (RearPlugIn[11,number])
MU_Connected = MU_F | MU_R

#RUNNING MODE
Tick = clk("clk")
if(On1|On2){
    
    #AIR COMPRESSORS ON/OFF
    
    if(MU_Connected & changed(MU_Connected) & HasPM){
        soundPitch(0,100 + !MU_Master*2*MU_Connected,1)
    }
    local CanCompress = HasPM ? 1 : MU_Connected
    if(((MainRes<130) | MU_Compress) & CanCompress){
        if(!CompQ1 & On1){
            CompQ1 = 1
            if(HasPM){
                H1:soundPlay(8,0,CompressorOn)
                if(!CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch)
                }
            }
        }
        if(!CompQ2 & DPM & On2){
            CompQ2 = 1
            H2:soundPlay(9,0,CompressorOn)
            if(!CompressorType){
                local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                soundPitch(9,CompressorPitch)
            }else{
                soundPitch(9,98)
            }
        }
        
    }elseif((((MainRes>=140) & (CFM<1)) & !MU_Compress) | !CanCompress){
        if(CompQ1){
            CompQ1 = 0
            if(HasPM){
                H1:soundPlay(8,0,CompressorOff)
                if(!CompressorType){
                    local CompressorPitch = 100 + EngineSpeed1*CPitch/NumEngineNotches
                    soundPitch(8,CompressorPitch)
                }
            }
        }
        if(CompQ2){
            CompQ2 = 0
            H2:soundPlay(9,0,CompressorOff)
            if(!CompressorType){
                local CompressorPitch = 98 + EngineSpeed2*CPitch/NumEngineNotches
                soundPitch(9,CompressorPitch)
            }else{
                soundPitch(9,98)
            }
        }
    }
    
    #SPEED INFO
    V = -E:velL():z()
    MPH = toUnit("mph",abs(V))*4/3
    KPH = toUnit("km/h",abs(V))*4/3
    
    #HANDBRAKE
        
    HandBrake = CtlTable["HandBrake",number]
    if(HandBrake & !HandBrakeQ & (MPH<5)){
        HandBrakeQ = 1
        Pod:driver():printProper("[RLCPT] Tightening Handbrakes...")
        timer("HandBrake",1000)
    }elseif(!HandBrake & HandBrakeQ){
        HandBrakeQ = 0
        stoptimer("HandBrake")
    }
    
    if((On1 & Isolation1)|(DPM&(On2 & Isolation2))){
        
        #HEP
        if(HEP & (Reverser==0) & (Throttle==0)){
            if(HEP_Up & !HEPQ & (HEP_Notch<2)){
                HEPQ = 1
                HEP_Notch++
                soundPlay(3,1,Button_HEP)
            }elseif(HEP_Dn & !HEPQ & (HEP_Notch>0)){
                HEPQ = 1
                HEP_Notch--
                soundPlay(3,1,Button_HEP)
            }elseif(!HEP_Up & !HEP_Dn & HEPQ){
                HEPQ = 0
            }
        }
        
        #CLAG
        if(HEP_Notch){
            if(!HEPCLAG & (MPH<10) & (Load>200)){
                HEPCLAG = 1
            }elseif(HEPCLAG & ((MPH>20) | (Load<100))){
                HEPCLAG = 0
            }
        }
        
        
        
        #if(On1 & Run & HasPM){Clag1 = HEP_Notch ? HEPCLAG : Notch>EngineSpeed1}
        #if(On2 & Isolation2){Clag2 = HEP_Notch ? HEPCLAG : Notch>EngineSpeed2}
        
        
        
        
        if(MU_Master){
            
            #MASTER MODE
            local Driver = noentity()
            local PodDriver = Pod:driver()
            if(RemoteMode){
                if(Active & !PodDriver){
                    Driver = owner()
                }
            }else{
                Driver = Pod:driver()
            }
            
            #Control Resolution From Input Table
            
            #SetReverser = CtlTable["SetReverser",number]
            #SetThrottle = CtlTable["SetThrottle",number]
            #SetDynamics = CtlTable["SetDynamics",number]
            #SetSelector = CtlTable["SetSelector",number]
            
            #ReverserF = CtlTable["ReverserF",number]
            #ReverserB = CtlTable["ReverserB",number]
            
            #IncreaseThrottle = CtlTable["IncreaseThrottle",number]
            #DecreaseThrottle = CtlTable["DecreaseThrottle",number]
            
            #IncreaseDynamics = CtlTable["IncreaseDynamics",number]
            #DecreaseDynamics = CtlTable["DecreaseDynamics",number]
            
            #IncreaseTrainBrake = CtlTable["IncreaseTrainBrake",number]
            #DecreaseTrainBrake = CtlTable["DecreaseTrainBrake",number]
            
            #IncreaseLocoBrake = CtlTable["IncreaseLocoBrake",number]
            #DecreaseLocoBrake = CtlTable["DecreaseLocoBrake",number]
            
            #TransitionUp = CtlTable["TransitionUp",number]
            #TransitionDown = CtlTable["TransitionDown",number]
            
            EmergencyBrake = CtlTable["EmergencyBrake",number]
            
            #Handbrake has been moved
            Sander = CtlTable["Sander",number]
            
        }else{
            
            #TRAILING MODE
            
            
            #MU Info Register
            #1 - Reverser
            #2 - Throttle
            #3 - Dynamic Brake
            #4 - Main Reservoir
            #5 - Locomotive Brake
            #6 - Hump Control
            #7 - Horsepower
            #8 - Total Effective Units
            #9 - Compressing
            #10 - Headlight
            #11 - "Heartbeat"
            #12 - Sand
            #13 - TransitionNotch
            
            if(MU_Connected){
                #print("Receiving")
                if(!AC_PlugNope){Reverser = -FrontPlugIn[1,number] + RearPlugIn[1,number]}
                Throttle = AC_PlugNope ? 0 : (FrontPlugIn[2,number] + RearPlugIn[2,number])
                DynamicBrakingPower = AC_PlugNope ? 100 : (FrontPlugIn[3,number] + RearPlugIn[3,number])
                if((FrontPlugIn[11,number]==2) | (RearPlugIn[11,number]==2)){
                    MainRes = max(FrontPlugIn[4,number],RearPlugIn[4,number])
                }
                
                LocoBrakePressure = FrontPlugIn[5,number] + RearPlugIn[5,number]
                SignalToLB = LocoBrakePressure>0
                if(TransitionControlType<2){SelectorNotch = max(FrontPlugIn[13,number],RearPlugIn[13,number])}
            }else{
                Reverser = 0
                Throttle = 0
                DynamicBrakingPower = 0
                
                LocoBrakePressure = 0
            }
            
            
        }
        
        #Slug Input Current
        if(SlugMode){
            InputCurrent = FrontCurrentIn[3,number] + RearCurrentIn[3,number]
            #print(InputCurrent)
        }else{
            CurrentDraw = FrontCurrentIn[3,number] + RearCurrentIn[3,number]
        }
        
        
        #AC TM Plugging
        
        if(MotorType & abs(Reverser)){
            local Plug = sign(V)!=Reverser
            if(Plug & !AC_PlugNope & (MPH>1.5)){
                AC_PlugNope = 1
            }
        }
        #Get me Excited
        Excitation = GenField ? 1 : (FrontPlugIn[6,number]|RearPlugIn[6,number])
        
        
        #THROTTLE
        
        if(AC_PlugNope){
            Throttle = 0
        }elseif(MU_Master){
            Throttle = CtlTable["SetThrottle",number]
        }
        
        Notch = adc(0,100,NumThrottleNotches,Throttle)
        if(HEP_Notch){
            Power = (HEP_Notch==2) ? Throttle : 0
        }elseif(!Dynamics){
            Power = HasPM ? (min((EngineSpeed1==round(Notch*NumEngineNotches/NumThrottleNotches)) ? Throttle : dac(0,100,NumEngineNotches,EngineSpeed1), Throttle)) : Throttle
        }else{
            Power = 0
        }
        
        
        if(MU_Master){
            #DYNAMIC BRAKES
            
            #Blended Braking
            
            if(!Emergency & BlendedBraking & DynamicsMode & (BrakeCyl>0) & (MPH>10)){
                local MaxDynaPower = 2800/MPH
                ForceDynaPower = clamp(min(BrakeCyl*2,MaxDynaPower),0,100)
                
            }else{
                ForceDynaPower = 0
            }
            WillItBlend = ForceDynaPower>0
            
            #Actual Dynamics
            
            if(AC_PlugNope){
                DynamicBrakingPower = 100
            }else{
                DynamicBrakingPower = CtlTable["SetDynamics",number]
            }
            DynaNotch = Dynamics ? adc(10,100,NumThrottleNotches,DynamicBrakingPower) : -1
            
            
            #Manual Transition
            SelectorNotch = (TransitionControlType < 2) ? CtlTable["SetSelector",number] : 1
            
            #REVERSER
            
            Reverser = CtlTable["SetReverser",number]*(UsingRearSeat ? -1 : 1)
            
            
            #End of MU Master Block
        }elseif(MU_Connected){
            BrakeNotch = 0
            EqualRes = 90
            BrakePipe = 90
            BrakeCyl = 0
            
            DynaNotch = Dynamics ? adc(10,100,NumThrottleNotches,DynamicBrakingPower) : -1
        }
        
        if((abs(Reverser)) & (Power==0) & ((DynamicBrakingPower + ForceDynaPower)>0) & !Dynamics){
            Dynamics = 1
            if(HasTM){W:soundPlay(5,0,DynamicsOn)}
        }elseif(((Power>0) | ((DynamicBrakingPower + ForceDynaPower)==0) | (!abs(Reverser))) & Dynamics){
            Dynamics = 0
            if(HasTM){W:soundPlay(5,0,DynamicsOff)}
        }
        
        
        if(HasPM){
            if(HEP_Notch){
                EngineNotch1 = HEPTYPE ? max(HEP_Notch*2,Notch) : HEP_Notch*4
            }elseif(Dynamics & (DynamicsMode==1)){
                
                if(DB_Damage){
                    DB_Level = 50
                }elseif(DB_Throttle==0){ #PM Adjustment Hysteresis for DB
                    local DBH = 25
                    switch(DB_Level){
                        case 50,
                            if(-Load>(MaxDynLoad*0.66 + DBH)){
                                DB_Level = 75
                            }
                            break
                        case 75,
                            if(-Load>(MaxDynLoad*0.83 + DBH)){
                                DB_Level = 100
                            }elseif(-Load<(MaxDynLoad*0.66 - DBH)){
                                DB_Level = 50
                            }
                            break
                        case 100,
                            if(-Load<(MaxDynLoad*0.83 - DBH)){
                                DB_Level = 75
                            }
                            break
                        default,
                            DB_Level = 50
                            break
                    }
                }else{
                    DB_Level = DB_Throttle
                }
                
                EngineNotch1 = (DynamicsMode==1) ? round(adc(0,100,NumEngineNotches,DB_Level)) : 0
            }else{
                EngineNotch1 = round(adc(0,100,NumEngineNotches,Throttle))
            }
        }else{
            EngineNotch1 = 0
        }
        #SANDER
        
        if(HasTM){
            if(Sander & !SandQ){
                SandQ = 1
                ForceSand = !ForceSand
            }elseif(!Sander & SandQ){
                SandQ = 0
            }
            local MU_Sand = FrontPlugIn[12,number] | RearPlugIn[12,number]
            
            if((ForceSand | ((TractionMode==2) & WheelSlip) | MU_Sand) & !Sanding){
                Sanding = 1
                Pod:soundPlay(13,0,SanderOn)
            }elseif(Sanding & !ForceSand & ((TractionMode!=2) | !WheelSlip) & !MU_Sand){
                Sanding = 0
                Pod:soundPlay(13,2,SanderOff)
            }
            
            #TRACTION MOTOR DRONE ON/OFF    
            if(HasTM){
                if((RollQ) & !DroneQ){
                    DroneQ = 1
                    H1:soundPlay(2,0,TractionDrone)
                    #print("Drone On")
                }elseif(!RollQ & DroneQ){
                    DroneQ = 0
                    soundStop(2,0.1)
                    #print("Drone Off")
                }
            }
            
        } 
        
        #POWER
        local Motoring = (TransitionControlType>1) ? (1) : (SelectorNotch>0)
        HumpMultiplier = GenField ? CtlTable["SetHumpMultiplier",number] : max(FrontPlugIn[17,number],RearPlugIn[17,number])
        if(((Power>0)|(Load>0)) & !Dynamics & abs(Reverser) & (MPH<TopSpeed) & Motoring & Excitation){
            
            #local MaxGenCurrent = 4250+(Horsepower/4) #Calibration Point: 3000HP -> 5000A
            #local RatedGenCurrent = 0
            
            if(!HasTM){
                Motors = max(FrontCurrentIn[2,number],RearCurrentIn[2,number])
            }
            
            local PowerNormal = (Power>0) ? (0.2 + (Power/100)*0.8)*HumpMultiplier : 0
            #local PowerNormal = (Power/100)^1.4
            local ShuntFactor = 1
            local HP_Effective = HEP_Notch ? (Horsepower-HEP_Subtract) : Horsepower
            
            if(TransitionMode){
                if((TransitionControlType==1)){ #Automatic With Selector
                    
                    if(SelectorNotch==0){
                        TransitionNotch==0
                    }else{
                        local T_N = 1
                        if(!GeneratorTransition){
                            for(N=1,TransitionNotches-1){
                                if(MPH > TransitionThresholds[N+1,number]){
                                    T_N++
                                }
                            }
                        }
                        TransitionNotch = T_N
                    }
                }elseif(TransitionControlType==2){ #Fully Automatic
                    local T_N = 1
                        if(!GeneratorTransition){
                            for(N=1,TransitionNotches-1){
                                if(MPH > TransitionThresholds[N+1,number]){
                                    T_N++
                                }
                            }
                        }
                    TransitionNotch = T_N
                }else{ #Manual
                    TransitionNotch = min(4,MU_Master ? SelectorNotch : TransitionNotch)
                }
            }else{
                TransitionNotch = 1
            }
            
            ShuntFactor = TransitionShunts[TransitionNotch+1,number]
            SeriesFactor = TransitionGroups[TransitionNotch+1,number]
            
            if(SlugMode){
                AvCurrent = InputCurrent
                #print(AvCurrent)
            }else{
            
                GenSeries = 0
                if(GeneratorTransition){
                    GenSeries = (MPH) > GenThreshold
                }
                
                local TM_Voltage = (MPH/TopSpeed)*NominalVoltage*ShuntFactor
                local Voltage = TM_Voltage*SeriesFactor*(GenSeries ? 0.5 : 1)
                #local Voltage = X
                local MaxPowerCurve = 746*HP_Effective*sqrt(PowerNormal)/max(Voltage,1)
                local MaxLoadCurve = (-0.125*Voltage + MaxGenCurrent)*PowerNormal
                local MaxFieldCurve = GeneratorTransition ? -4*(Voltage - 2*NominalVoltage)  : -4*(Voltage-NominalVoltage) 
                
                GenCurrent = min(MaxLoadCurve,MaxPowerCurve,MaxFieldCurve)*(GenSeries ? 0.5 : 1)

                AvCurrent = clamp(GenCurrent-CurrentDraw,0,MaxGenCurrent)
                Currents = array(MaxLoadCurve, MaxPowerCurve, MaxFieldCurve)
                
            }
            
            #Load Smoothing
            
            Load_Setpoint = HasTM ? clamp(AvCurrent*SeriesFactor/Motors,0,MaxLoad) : 0
            
            if(APR==1){
                if(Load<Load_Setpoint){
                    Load += LoadRampSpeed*(1 + 2*PowerNormal)
                    if(Load>Load_Setpoint){
                        Load = Load_Setpoint
                    }
                }elseif(Load>Load_Setpoint){
                    Load += -20
                    if(Load<Load_Setpoint){
                        Load = Load_Setpoint
                    }
                }
            }else{
                Load = Load_Setpoint
            }
            
            #Wheel Slip
            
            if(TractionMode>0){
                if(WheelSlipLocal & (APR>0)){
                    APR += (TractionMode==3) ? -0.01 : -0.005
                }elseif(!WheelSlipLocal & (APR<1)){
                    APR += (TractionMode==3) ? 0.01 : 0.005
                }
                Load = Load*APR
            }
            #TM Overload Protection
            if(OverloadProtection){
                if(OLP_Engaged){
                    if((Load>MaxContLoad) & (OLPR>0)){
                        OLPR += -0.01
                        if(OLPR<0){OLPR = 0}
                    }elseif((Load<(MaxContLoad-20)) & (OLPR<1)){
                        OLPR += 0.01 
                        if(OLPR>1){OLPR = 1}
                    }
                }else{
                    if(OLPR<1){
                        OLPR += 0.01
                        if(OLPR>1){OLPR = 1}
                    }
                }
                Load = Load*OLPR
            }
            
            #Wheel Slip (Cont)
            local Bonus = Sanding*0.125
            
            local AxlesSlipping = 0
            local OneOfTheAxlesSlippingIsTheOneWithTheLoadMeter = 0
            WheelSlipThreshold = TE_Starting*(1+Bonus)*0.072
            if((Load>WheelSlipThreshold) & !WheelSlipLocal & 1){
                WheelSlipLocal = 1
                W:soundPlay(12,0,WheelSlipOn)
                AxlesSlipping = 1 + (Load>(WheelSlipThreshold*1.1)) + (Load>(WheelSlipThreshold*1.2))
                for(N=1,AxlesSlipping){
                    OneOfTheAxlesSlippingIsTheOneWithTheLoadMeter = (random()>0.5)
                    if(OneOfTheAxlesSlippingIsTheOneWithTheLoadMeter==1){
                        break
                    }
                }
            }elseif(Load<(WheelSlipThreshold*0.75) & WheelSlipLocal){
                WheelSlipLocal = 0
                W:soundPlay(12,0,WheelSlipOff)
                WheelSlipRand = 0
            }
            local Load_Eff = Load*(TM_Health/100)
            if(WheelSlipLocal){
                Load_Eff *= ((2*Motors - AxlesSlipping)/(2*Motors))
                if(OneOfTheAxlesSlippingIsTheOneWithTheLoadMeter){Load *= 0.5}
            }
            
            WheelSlip = WheelSlipLocal | FrontPlugIn[14,number] | RearPlugIn[14,number]
            local DPMF = (On1&Isolation1) + (On2&Isolation2)
            TE = DPMF*sign(Reverser)*Load_Eff*(BaseSpeed/TopSpeed)*ShuntFactor*Motors*1500/8
            
        }elseif(Dynamics & HasTM & Excitation){ #Dynamic Brake Calcs
            Voltage = 0
            Load = -(max(DynamicBrakingPower,ForceDynaPower))*MPH/4
            if(DB_Damage){
                Load = random()*Load/2
                #print(Load)
            }
            if(LimitCurrent & (Load<-MaxDynLoad)){Load = -MaxDynLoad}
            TE = WillItBlend ? 0 : -sign(V)*abs(Load)*(Motors)*(BaseSpeed/TopSpeed)*250
            
            if(-Load > MaxDynLoad){ #DB Consequences
                DB_Temp += linterp(-Load,vec2(MaxDynLoad,1/DB_Maxtime),vec2(MaxDynLoad+300,1/DB_Mintime))
                if((DB_Temp>60) & !DB_Warning){
                    DB_Warning = 1
                    Pod:driver():printProper("[RLCPT] Warning! Your dynamic brakes are in danger of overheating! Reduce load to below " + MaxDynLoad:toString() + " Amps or dynamic brake damage will occur!")
                    timer("dbdamage",7500)
                }
            }else{
                if(DB_Warning & !DB_Damage){
                    DB_Warning = 0
                    stoptimer("dbdamage")
                }
                if(DB_Temp > 0){
                    DB_Temp += (-2/DB_Maxtime)*50/1000
                }
            }
            
            if((Load<-200) & (Cyl>(ClaspBrakes ? 20 : 40))){
                #print(TotalEffortOnAxle+"/"+(TE_Starting*32.17))
                Load = 0
                TE = 0
                WheelSlip = 1
            }else{
                WheelSlip = 0
            }
            if(WheelSlip & !SlideQ){
                SlideQ = 1
                W:soundPlay(12,0,WheelSlide)
            }elseif(!WheelSlip & SlideQ){
                SlideQ = 0
                soundStop(12)
            }
            BrakeWarning = Load<-MaxDynLoad
        }else{
            Load = Voltage = TE = 0
            if(WheelSlip & SlideQ){
                SlideQ = 0
                soundStop(12)
            }
            if(WheelSlip){
                WheelSlip = 0
                W:soundPlay(12,0,WheelSlipOff)
            }
        }
        
        #Loadmeter Splits
        Load1 = Load*On1*Isolation1
        Load2 = Load*On2*Isolation2
        
        #Short Time Consequences
        if(Load > MaxContLoad){
            TM_Temp += linterp(Load,vec2(MaxContLoad,1/TM_Maxtime),vec2(MaxLoad,1/TM_Mintime))*50/1000
            if((TM_Temp>60) & !TM_Warning){
                TM_Warning = 1
                if(OverloadProtection){
                    Pod:driver():printProper("[RLCPT] Warning! Your traction motors are in danger of overheating! Load will be reduced automatically below " + MaxContLoad:toString() + " until motor temperatures drop!")
                    OLP_Engaged = 1
                    OLPR = 1
                }else{
                    Pod:driver():printProper("[RLCPT] Warning! Your traction motors are in danger of overheating! Reduce load to below " + MaxContLoad:toString() + " Amps or traction motor damage will occur!")
                    timer("motordamage",15000)
                }
                #You wanna die, buddy?
            }elseif(TM_Damage){
                if(!TM_ZapQ){
                    TM_ZapQ = 1
                    W:soundPlay(14,0,MotorDamaging)
                    #There will be CONSEQUENCES!
                }
                TM_Health -= 1.25
                if(TM_Health <= 0){
                    soundStop(14)
                    HasTM = 0
                    DroneQ = 0
                    W:soundPlay(2,3,MotorDeath)
                    Load = 0
                    SandQ = 0
                    ForceSand = 0
                    #*Truck Smashes into car*
                }
            }
        }else{
            if(TM_Warning){
                TM_Warning = 0
                TM_Damage = 0
                TM_ZapQ = 0
                stoptimer("motordamage")
            }
            if((TM_Temp < 30) & OLP_Engaged){
                OLP_Engaged = 0
            }
            if(TM_Temp > 0){
                TM_Temp += (-2/TM_Maxtime)*50/1000
            }
        }
        
        #DPM Delay
        if(DPM & On2 & Isolation2){
            if(changed(Reverser)){
                timer("DPM_Rev",DPM_Delay)
            }
            if(changed(EngineNotch1)){
                timer("DPM_Eng",DPM_Delay)
                #print("AAA DPM")
            }
        }
        
        #Traction Motor Drone
        if(DroneQ){
            #Y - Y1 = m(X - X1)
            #P - 100 = m(MPH - 20)
            #P = m(MPH) - m(20) + 100
            soundPitch(2,100*MPH/40)
            soundVolume(2,clamp((MPH/5),0,1)*clamp(abs(Load)/200,0.5,1))
        }
        
    }else{#End of Running Block
        TE = 0
        Load = 0
        EngineNotch1 = EngineNotch2 = 0
    }
    
    #ENGINE SOUND CODE
    if(HasPM){
        #Low Idle 1
        if(FuelSaverMode){
            LowIdleCondition1 = (EngineNotch1==0) & (EngineSpeed1==0) & (Reverser==0)
            if(On1 & !Starting1){
                if(LowIdleCondition1 & !LowIdling1 & !LowIdleWaiting1){
                    if(FuelSaverDelay>0){
                        LowIdleWaiting1 = 1
                        timer("IdleDown1",FuelSaverDelay*1000)
                    }elseif(!TQ1){
                        TQ1 = 1
                        LowIdling1 = 1
                        TQ1 = 1
                        local Snd = TransitionToLow
                        H1:soundPlay(0,0,Snd)
                        #print("Pootis1")
                        stoptimer("TQU1")
                        timer("TQD1",sdr(Snd))
                    }else{
                        LowIdling1 = 1
                        LRQ1 = 1
                        soundVolume(0,0,1)
                        local Snd = TransitionToLow
                        H1:soundPlay(10,0,Snd)
                        soundVolume(10,0)
                        soundVolume(10,1,0.5)
                        #print("Pootis2")
                        stoptimer("TQU1")
                        timer("TQD1",sdr(Snd))
                    }
                }elseif(!LowIdleCondition1 & LowIdling1){
                    if(!TQ1){
                        LowIdling1 = 0
                        TQ1 = 1
                        LRQ1 = 1
                        local Snd = TransitionToHigh
                        H1:soundPlay(0,0,Snd)
                        stoptimer("TQD1")
                        timer("TQU1",sdr(Snd))
                    }else{
                        LowIdling1 = 0
                        LRQ1 = 1
                        soundVolume(0,0,1)
                        local Snd = TransitionToHigh
                        H1:soundPlay(10,0,Snd)
                        soundVolume(10,0)
                        soundVolume(10,1,0.5)
                        stoptimer("TQD1")
                        timer("TQU1",sdr(Snd))
                    }
                }
            
                if(!LowIdleCondition1 & LowIdleWaiting1){
                    stoptimer("IdleDown1")
                    LowIdleWaiting1 = 0
                }
            }
            
            #Low Idle 2
            
            LowIdleCondition2 = (EngineNotch2==0) & (EngineSpeed2==0) & (Reverser==0)
            if(DPM & On2 & !Starting2){
                LowIdleCondition2 = (Throttle==0) & (EngineSpeed2==0) & (Reverser_DPM==0)
                
                if(LowIdleCondition2 & !LowIdling2 & !LowIdleWaiting2){
                    if(FuelSaverDelay>0){
                        LowIdleWaiting2 = 1
                        timer("IdleDown2",FuelSaverDelay*1000)
                    }elseif(!TQ2){
                        TQ2 = 1
                        LowIdling2 = 1
                        TQ2 = 1
                        local Snd = TransitionToLow
                        H2:soundPlay(1,0,Snd)
                        soundPitch(1,98)
                        stoptimer("TQU2")
                        timer("TQD2",sdr(Snd))
                    }else{
                        LowIdling2 = 1
                        LRQ2 = 1
                        soundVolume(1,0,1)
                        local Snd = TransitionToLow
                        H2:soundPlay(11,0,Snd)
                        soundVolume(11,0)
                        soundVolume(11,1,0.5)
                        stoptimer("TQU2")
                        timer("TQD2",sdr(Snd))
                    }
                }elseif(!LowIdleCondition2 & LowIdling2){
                    if(!TQ2){
                        LowIdling2 = 0
                        TQ2 = 1
                        LRQ2 = 1
                        local Snd = TransitionToHigh
                        H2:soundPlay(1,0,Snd)
                        soundPitch(1,98)
                        stoptimer("TQD2")
                        timer("TQU2",sdr(Snd))
                    }else{
                        LowIdling2 = 0
                        LRQ2 = 1
                        soundVolume(1,0,1)
                        local Snd = TransitionToHigh
                        H2:soundPlay(11,0,Snd)
                        soundPitch(11,98)
                        soundVolume(11,0)
                        soundVolume(11,1,0.5)
                        stoptimer("TQD2")
                        timer("TQU2",sdr(Snd))
                    }
                }
            
                if(!LowIdleCondition2 & LowIdleWaiting2){
                    stoptimer("IdleDown2")
                    LowIdleWaiting2 = 0
                }
            }
        }
        
        if(clk("TQU1")|clk("TQD1")){
            #print("TQ1",EngineNotch1,EngineSpeed1)
            #print("CCC")
            if((EngineSpeed1==EngineNotch1) & (ABlendQ1==0)){
                local Snd = LowIdling1 ? Idle_Low : Notches[EngineSpeed1+1,string]
                #print(Snd)
                H1:soundPlay(0,0,Snd)
                soundPitch(0,100 + !MU_Master*2*MU_Connected)
                LRQ1 = 0
                Clag1 = 0
                RevDirection1 = 0
                AnyBlendQ1 = 0
            }
            TQ1 = 0
            #print("TQU1")
            LowIdleWaiting1 = 0
        }
        if(!LowIdling1 & !LowIdleWaiting1){
            if((EngineNotch1+ABlendQ1) > EngineSpeed1){
                if(!TQ1 | (RevDirection1==-1)){
                    TQ1 = 1
                    transitionUp1(EngineSpeed1,EngineNotch1+ABlendQ1)
                }
            }elseif((EngineNotch1+ABlendQ1) < EngineSpeed1){
                if(!TQ1 | (RevDirection1==1)){
                    TQ1 = 1
                    transitionDown1(EngineSpeed1,EngineNotch1+ABlendQ1)
                }
            }
        }
        if(clk("TQU2")|clk("TQD2")){
            #print("TQ1",EngineNotch1,EngineSpeed1)
            if((EngineSpeed2==EngineNotch2) & (ABlendQ2==0)){
                local Snd = LowIdling2 ? Idle_Low : Notches[EngineSpeed2+1,string]
                #print(Snd)
                H2:soundPlay(1,0,Snd)
                soundPitch(1,98)
                LRQ2 = 0
                Clag2 = 0
                RevDirection2 = 0
                AnyBlendQ2 = 0
            }
            TQ2 = 0
            #print("TQU1")
            LowIdleWaiting2 = 0
        }
        if(!LowIdling2 & !LowIdleWaiting2){
            if((EngineNotch2+ABlendQ2) > EngineSpeed2){
                if(!TQ2 | (RevDirection2==-1)){
                    TQ2 = 1
                    transitionUp2(EngineSpeed2,EngineNotch2+ABlendQ2)
                }
            }elseif((EngineNotch2+ABlendQ2) < EngineSpeed2){
                if(!TQ2 | (RevDirection2==1)){
                    TQ2 = 1
                    transitionDown2(EngineSpeed2,EngineNotch2+ABlendQ2)
                }
            }
        }
    }
    #End of Engine Sound Block
    
    
    #Locomotive Current Line
    #1 - Heartbeat
    #2 - MotorCount
    #3 - GenCurrent/CurrentDraw
    
    if(SlugMode){
        FrontCurrentOut = array(1,Motors,AvCurrent)
        RearCurrentOut = FrontCurrentOut:clone()
    }else{
        local Slugs = FrontCurrentIn[1,number]+RearCurrentIn[1,number]
        FrontCurrentOut = array(1,Motors,GenCurrent/(max(HasTM+Slugs,1)))
        RearCurrentOut = FrontCurrentOut:clone()
    }
    
    #End of ON Block
}

#AIR BRAKE MEGABLOCK

MU_ResVol = FrontPlugIn[18,number] + RearPlugIn[18,number] + MainResVolume

if(Tick){
    if(changed(CarCount) & (($CarCount)>0)){
        BrakePipe *= abs(CarCount - $CarCount)/CarCount
        AuxRes *= abs(CarCount - $CarCount)/CarCount
    }
    
    local BrakeNotch = CtlTable["SetBrakeNotch",number]
    local SetEqualRes = CtlTable["SetEqualRes",number]
    local SetBleeding = CtlTable["SetBleeding",number]
    local SetHolding = CtlTable["SetHolding",number]
    local Overcharge = CtlTable["Overcharge",number] #What do you mean, "Overcha-"
    local FRC = CtlTable["FRC",number]
    
    #AC to MR
    if(BrakeCutIn | !MU_Connected | (FrontPlugIn[4,number]+RearPlugIn[4,number]==0)){
        #P1V1 = P2V2 -> V2 = P1V1/P2
        local TotalSCFM = FrontPlugIn[16,number] + RearPlugIn[16,number] + Compressor_CFM*(CompQ1+CompQ2)*(CompressorType ? 1 : 0.25 + 0.75*EngineSpeed1/NumEngineNotches)
        local TotalCFM = TotalSCFM*14.7/(MainRes+14.7)
        local Add = TotalCFM*0.5/MU_ResVol
        MainRes += Add
        if(MainRes>140){
            MainRes = 140
        }
        #print("TotalCFM: "+round(TotalCFM,2)+", Res Vol: "+round(MU_ResVol,2)+", Add: "+round(Add,4))
    }
    
    if(BrakeCutIn){
        #AUTOMATIC BRAKES
        
        #Equalizing Reservoir
        if(SetEqualRes>EqualRes){ #Recharge
            EqualRes += 2
            if(EqualRes>=SetEqualRes){EqualRes = SetEqualRes}
        }elseif(SetEqualRes<EqualRes){ #Reduction
            EqualRes -= 2
            if(EqualRes<=SetEqualRes){EqualRes = SetEqualRes}
        }
        
        local BrakePipeVol = 2.7
        local AuxResVol = 2
        
        #P*V = Air
        
        #90*4 = 360
        #P = 360/5 = 72
        
        if(BrakePipe<AuxRes){ #Reduction
            if(AuxRes>0){
                AuxRes += -2
                if(AuxRes<0){AuxRes = 0}
                if(AuxRes<BrakePipe){AuxRes = BrakePipe}
                
                BrakeCyl = (AuxMaxPressure-AuxRes)*72/90
                if(!SetBleeding & (BleedPressure<BrakeCyl)){
                    BleedPressure = BrakeCyl
                }
            }
            
        }elseif(BrakePipe>AuxRes){ #Release/Charge
            
            #BC to Atmosphere
            if(GraduatedRelease){
                local TargetPressure = FeedPressure-BrakePipe
                if(BrakeCyl>TargetPressure){
                    BrakeCyl += -2
                    if(BrakeCyl<TargetPressure){BrakeCyl = TargetPressure}
                }
            }elseif(BrakeCyl>0){
                BrakeCyl += -4
                if(BrakeCyl<0){BrakeCyl = 0}
            }
            
            #BP to AR
            local AuxRate = 4 #Max Change in AR PSI per Second
            
            AuxRes += AuxRate/AuxResVol
            BrakePipe += -AuxRate/BrakePipeVol
            if(AuxRes>BrakePipe){
                local TotalVol = BrakePipeVol+AuxResVol
                local Avg = (BrakePipeVol/TotalVol)*BrakePipe + (AuxResVol/TotalVol)*AuxRes
                BrakePipe = AuxRes = Avg
            }
            AuxMaxPressure = AuxRes
            
        }
        
        #MR to BP
        if(Overcharge){
            if(!FRC & (BrakePipe>(FeedPressure-2.5))){
                Overcharge = 0
            }
        }
        local TargetPipe = Overcharge ? MainRes : EqualRes
        CFM = 0
        if(BrakePipe>TargetPipe){ #Reducing
            BrakePipe += -1/(CarCount/16 + 1)
            if(BrakePipe<TargetPipe){BrakePipe = TargetPipe}
        }elseif(BrakePipe<TargetPipe){ #Recharging
            if(MainRes>=TargetPipe){
                CFM = max((Overcharge ? MainRes : FeedPressure) - BrakePipe,10)*2/3
                local TotalBPVol = BrakePipeVol*max(CarCount,1)
                BrakePipe += CFM*0.5/TotalBPVol
                if(CarCount>0){MainRes += -CFM*0.5/MU_ResVol}
                if(BrakePipe>TargetPipe){BrakePipe = TargetPipe}
            }else{CFM = 0}
        }
        local Units = FrontPlugIn[8,number] + RearPlugIn[8,number] + 1
        CFM = CFM/Units
        
        
        #End of Airbrakes Cut-In Block
    }else{

    }
    
    
    #INDEPENDENT BRAKES
        
    LocoBrakePressure = BrakeCutIn ? CtlTable["SetLocoBrakePressure",number] : max(FrontPlugIn[5,number],RearPlugIn[5,number])
    
    if(SetBleeding){
        if(Cyl>0){
            Cyl += -4
            if(Cyl<0){Cyl=0}
            BleedPressure = Cyl
        }
    }elseif(!SetHolding){
        if((LocoBrakePressure>0) & (BleedPressure<72)){
            BleedPressure = 72
        }
        local SetLBP = clamp(max(LocoBrakePressure,min(Dynamics ? 0 : BrakeCyl,BleedPressure)),0,72)
        if(Cyl<SetLBP){
            Cyl += 2
            if(Cyl>SetLBP){Cyl = SetLBP}
        }elseif(Cyl>SetLBP){
            Cyl += -2
            if(Cyl<SetLBP){Cyl = SetLBP}
        }
    }
    Cyl = min(Cyl,MainRes)
    
    #Cyl = Dynamics ? 0 : min(max(BrakeCyl, LocoBrakePressure, HoldingPressure),BleedPressure)
    
    
    
    
    local Braking_Train = BrakeCyl>0
    local Braking_Loco = Cyl>0
    
    #Brake Squeal
    if(Braking_Loco & (inrange(MPH,0.5,8)) & !SquealQ){
        SquealQ = 1
        W:soundPlay(6,0,BrakeSqueal)
    }elseif((!Braking_Loco | (!inrange(MPH,0.5,8))) & SquealQ){
        SquealQ = 0
        soundStop(6,0.5)
    }
    if((MPH>1) & !RollQ){
        RollQ = 1
        W:soundPlay(7,0,RailType ? RollSoundJointed : RollSoundWelded)
    }elseif((MPH<1) & RollQ){
        RollQ = 0
        soundStop(7)
    }
    if(RollQ){
        if(!RailType){
            local LeadTruck = (V>0) ? FrontTruck : RearTruck
            rangerFilter(W)
            rangerFilter(LeadTruck)
            local CCRanger = rangerOffset(128,LeadTruck:pos(),vec(0,0,-1))
            #print(CCRanger:entity())
            local OnSwitch = (CCRanger:entity():type())==("prop_dynamic")
            if(OnSwitch & !ClicketyQ){
                ClicketyQ = 1
                W:soundPlay(7,0,RollSoundJointed)
            }elseif(!OnSwitch & ClicketyQ){
                ClicketyQ = 0
                W:soundPlay(7,0,RollSoundWelded)
            }
        }
        soundPitch(7,MPH*3.3)
    }
    
    #Brake Physprops
    BE = (Cyl*BrakeMul*(ClaspBrakes ? 1.25 : 1)*Axles/6 + MaxTrainBrakeForce*BrakeCyl)*300/90 #If you adjust this, don't forget to correct the DB lockup code!
    Overcome = (abs(TE) - BE)>0
    if(BrakeCutIn){
        if((((Braking_Train | Braking_Loco) & (Power==0)) | HandBrakeOverride) & !BHQ & (MPH<1)){
            BHQ = 1
            abRest(Trucks)
            if(AC_PlugNope){AC_PlugNope = 0}
        }elseif((!(Braking_Train | Braking_Loco) | Overcome) & !HandBrakeOverride & BHQ){
            BHQ = 0
            abRelease()
            Emergency = 0
        }
    }else{
        if((SignalToLB) & (MPH<1) & AC_PlugNope){
            AC_PlugNope = 0
        }
        if(BHQ){
            BHQ = 0
        }
    }
    
    #APPLY THE BRAKES - DUMP THE AIR - STOP
    if((EmergencyBrake | (BrakeNotch==6)) & !Emergency){
        Emergency = 1
        soundPlay(4,6,AirBrakeDump)
        abEmergency(LastProps)
        BrakePipe = 0
        EqualRes = 0
        BrakeCyl = 90
        BleedPressure = 90
        
        Throttle = 0
        Notch = 0
        DynaNotch = -1
        DynamicBrakingPower = 0
        ForceDynaPower = 0
        BrakeNotch = 6
        
    }
    
    #FORCE APPLICATION
    if(BHQ){TE = 0}
    BE = sign(V)*(MPH>0.5)*BE
    if((TE!=0) | (BE!=0)){
        Force = TE - BE
        W:applyForce(-E:up()*(Force/2))
    }
    
    #TE in LBF
    
    #TE in Source is in units of kg-in/s^2
    #1 LBF = 32.17 lb-in/s^2
    
    TE_LBF = abs(round(toUnit("lb",TE)/32.17))

    stoptimer("clk")
    timer("clk",50)
}

#Ctl Re-Initialize
if(CtlTable["MUXed",number]){
    local ActiveStand = CtlTable["ActiveStand",number]
    if((ActiveStand==1) & (CtlInitQ!=1)){
        CtlInitQ = 1
        ctlTableInit()
    }elseif((ActiveStand==2) & (CtlInitQ!=2)){
        CtlInitQ = 2
        ctlTableInit()
    }elseif((ActiveStand==0) & (CtlInitQ!=0)){
        CtlInitQ = 0
    }
}

#MU OUTPUT
    
    #MU Info Register
    #1 - Reverser
    #2 - Throttle
    #3 - Dynamic Brake
    #4 - Main Reservoir
    #5 - Locomotive Brake
    #6 - MU Master Heartbeat
    #7 - Horsepower
    #8 - Units In Consist
    #9 - Compressing
    #10 - Headlight
    #11 - "Heartbeat"
    #12 - Sand
    #13 - TransitionNotch
    #14 - Wheel Slip
    #15 - Loco Weights (LB)
    #16 - Total Compressor CFM
    #17 - Hump Mult
    #18 - Total Main Res Volume
    #19 - Brake Warning
    
    
if((On1|On2) & MU_Master){
    FrontPlugOut = array(
        Reverser,
        Throttle,
        max(DynamicBrakingPower,ForceDynaPower),
        MainRes,
        LocoBrakePressure,
        GenField,
        Horsepower,
        RearPlugIn[8,number] + 1,
        CompQ1|CompQ2
    )
    RearPlugOut = array(
        -Reverser,
        Throttle,
        max(DynamicBrakingPower,ForceDynaPower),
        MainRes,
        LocoBrakePressure,
        GenField,
        Horsepower,
        FrontPlugIn[8,number] + 1,
        CompQ1|CompQ2
    )
    
    FrontPlugOut[11,number] = 2
    RearPlugOut[11,number] = 2
    
    FrontPlugOut[12,number] = ForceSand
    RearPlugOut[12,number] = ForceSand
    
    FrontPlugOut[13,number] = SelectorNotch
    RearPlugOut[13,number] = SelectorNotch
    
    FrontPlugOut[17,number] = HumpMultiplier
    RearPlugOut[17,number] = HumpMultiplier
}else{
    FrontPlugOut = RearPlugIn:clone()
    RearPlugOut = FrontPlugIn:clone()
    
    FrontPlugOut[8,number] = RearPlugIn[8,number] + 1
    RearPlugOut[8,number] = FrontPlugIn[8,number] + 1
    
    FrontPlugOut[7,number] = RearPlugIn[7,number] + Horsepower
    RearPlugOut[7,number] = FrontPlugIn[7,number] + Horsepower
    
    FrontPlugOut[11,number] = (RearPlugIn[11,number]==2) ? 2 : 1
    RearPlugOut[11,number] = (FrontPlugIn[11,number]==2) ? 2 : 1
}

FrontPlugOut[10,number] = RearPlugIn[10,number] | Lights_Front
RearPlugOut[10,number] = FrontPlugIn[10,number] | Lights_Rear

FrontPlugOut[14,number] = RearPlugIn[14,number] | WheelSlipLocal
RearPlugOut[14,number] = FrontPlugIn[14,number] | WheelSlipLocal

FrontPlugOut[15,number] = RearPlugIn[15,number] + Weight
RearPlugOut[15,number] = FrontPlugIn[15,number] + Weight

local CFM_Contribution = Compressor_CFM*(CompQ1+CompQ2)*(CompressorType ? 1 : 0.5 + 0.5*EngineSpeed1/NumEngineNotches)
FrontPlugOut[16,number] = RearPlugIn[16,number] + CFM_Contribution
RearPlugOut[16,number] = FrontPlugIn[16,number] + CFM_Contribution

FrontPlugOut[18,number] = RearPlugIn[18,number] + MainResVolume
RearPlugOut[18,number] = FrontPlugIn[18,number] + MainResVolume

FrontPlugOut[19,number] = RearPlugIn[19,number] | BrakeWarning
RearPlugOut[19,number] = FrontPlugIn[19,number] | BrakeWarning

BrakeWarn = BrakeWarning | DB_Damage | FrontPlugIn[19,number] | RearPlugIn[19,number]

Lights_Forward = MU_F ? 0 : FrontPlugOut[10,number]
Lights_Backward = MU_R ? 0 : RearPlugOut[10,number]

Lights_Fwd_RGB = Lights_Forward*HeadlightRGB
Lights_Back_RGB = Lights_Backward*HeadlightRGB


if(chatClk(O)|chatClk(Pod:driver())){
    local Speaker = lastSpoke()
    local Sentence = Speaker:lastSaid():explode(" ")
    local CMD_PreNum = Sentence[1,string]
    local CMD_S = CMD_PreNum:explode(":")
    local CMD = CMD_S[1,string]
    local NumberGiven = CMD_S[2,string]
    local Num = Number:trim()
    
    local OnRun = (On1 & Isolation1)|(On2 & Isolation2)
    
    if((NumberGiven==Num) | NumberGiven==""){
        switch(CMD){
            case ".quickstart1",
                if(1){
                    if(HasPM){
                        if(!On1){
                            On1 = 1
                            Primed1 = 1
                            PrimerSet1 = 1
                            if(FuelSaverMode & !LowIdling1){
                                TQ1 = 1
                                LowIdling1 = 1
                                TQ1 = 1
                                local Snd = TransitionPath+"down/1-0.wav"
                                H1:soundPlay(0,0,Snd)
                                timer("FinishStart1",sdr(Snd))
                            }else{
                                Starting1 = 0
                                H1:soundPlay(0,0,LowIdling1 ? Idle_Low : Notches[1,string])
                                soundPitch(0,100 + !MU_Master*2*MU_Connected)
                                
                                EngineNotch1 = 0
                                EngineSpeed1 = 0
                                stoptimer("clk")
                                timer("clk",100)
                            }
                        }
                    }else{
                        On1 = 1
                        EngineNotch1 = 0
                        EngineSpeed1 = 0
                        H1:soundPlay(0,1,Lever_Throttle)
                    }
                    MainRes = 140
                }else{
                    Speaker:printProper("[RLCPT] This command has been disabled.")
                }
                hideChat(1)
                break
            case ".quickstart2",
                if(1){
                    if(!On2){
                        On2 = 1
                        Primed2 = 1
                        PrimerSet2 = 1
                        if(FuelSaverMode & !LowIdling2){
                            TQ2 = 1
                            LowIdling2 = 1
                            TQ2 = 1
                            local Snd = TransitionPath+"down/1-0.wav"
                            H2:soundPlay(1,0,Snd)
                            soundPitch(1,98)
                            timer("FinishStart2",sdr(Snd))
                        }else{
                            Starting2 = 0
                            H2:soundPlay(1,0,LowIdling2 ? Idle_Low : Notches[1,string])
                            soundPitch(1,98)
                            
                            EngineNotch2 = 0
                            EngineSpeed2 = 0
                            stoptimer("clk")
                            timer("clk",100)
                        }
                    }
                    MainRes = 140
                }else{
                    Speaker:printProper("[RLCPT] This command has been disabled.")
                }
                hideChat(1)
                break
            case ".autostart1",
                hideChat(1)
                if(HasPM){
                    if(On1){
                        Speaker:printProper("[RLCPT] Prime Mover is already On!")
                    }elseif(Isolation1){
                        Speaker:printProper("[RLCPT] Isolation Switch is in Run!")
                    }elseif(Shutdown1){
                        Speaker:printProper("[RLCPT] Engine is being forced to Shut Down!")
                    }else{
                        timer("startprime1",500)
                        Speaker:printProper("[RLCPT] Starting Prime Mover 1...")
                    }
                }else{
                    On1 = 1
                    EngineNotch1 = 0
                    EngineSpeed1 = 0
                    H1:soundPlay(0,1,Lever_Throttle)
                    Speaker:printProper("[RLCPT] Unit Engaged!")
                }
                break
            case ".autostart2",
                hideChat(1)
                if(!DPM){
                    Speaker:printProper("[RLCPT] Locomotive has only one Prime Mover!")
                }elseif(On2){
                    Speaker:printProper("[RLCPT] Prime Mover is already On!")
                }elseif(Isolation2){
                    Speaker:printProper("[RLCPT] Isolation Switch is in Run!")
                }elseif(Shutdown2){
                    Speaker:printProper("[RLCPT] Engine is being forced to Shut Down!")
                }else{
                    timer("startprime2",500)
                    Speaker:printProper("[RLCPT] Starting Prime Mover 2...")
                }
                break
            case ".shutdown1",
                hideChat(1)
                if(HasPM){
                    if(On1){
                        Speaker:printProper("[RLCPT] Shutting Down Prime Mover 1...")
                        On1 = 0
                        if(PrimerSet1){PrimerSet1 = 0}
                        if(CompQ1){
                            CompQ1 = 0
                            H1:soundPlay(8,0,CompressorOff)
                            #soundPitch(8,100 + Power/2,1)
                        }
                        if(Prime1){
                            #print("Fuel Punp")
                            H1:soundPlay(2,0,PrimeOn)
                            soundVolume(2,0)
                            soundVolume(2,1,3)
                        }
                        local Snd = ""
                        switch(Shutdown_Mode){
                            case 0,
                                Snd = Shutdown_Lo
                                break
                            case 1,
                                Snd = Shutdown_Hi
                                break
                            case 2,
                                Snd = LowIdling1 ? Shutdown_Lo : Shutdown_Hi
                                break
                        }
                        H1:soundPlay(0,0,Snd)
                        stoptimer("IdleDown1")
                        interrupt(1)
                        timer("Cool1",sdr(Snd))
                    }else{
                        Speaker:printProper("[RLCPT] Prime Mover 1 is not On!")
                    }
                }else{
                    On1 = 0
                    CompQ1 = 0
                    Speaker:printProper("[RLCPT] Unit Disengaged!")
                
                }
                break
            case ".shutdown2",
                hideChat(1)
                if(DPM){
                    if(On2){
                        On2 = 0
                        if(PrimerSet1){PrimerSet1 = 0}
                        if(CompQ2){
                            CompQ2 = 0
                            H2:soundPlay(9,0,CompressorOff)
                            soundPitch(9,105,1)
                        }
                        if(Prime2){
                            #print("Fuel Punp")
                            H1:soundPlay(3,0,PrimeOn)
                            soundVolume(3,0)
                            soundVolume(3,1,3)
                        }
                        local Snd = ""
                        switch(Shutdown_Mode){
                            case 0,
                                Snd = Shutdown_Lo
                                break
                            case 1,
                                Snd = Shutdown_Hi
                                break
                            case 2,
                                Snd = LowIdling2 ? Shutdown_Lo : Shutdown_Hi
                                break
                        }
                        H2:soundPlay(1,0,Snd)
                        stoptimer("IdleDown2")
                        interrupt(2)
                        timer("Cool2",sdr(Snd))
                        #print("Shutdown2")
                    }else{
                        Speaker:printProper("[RLCPT] Prime Mover 2 is not On!")
                    }
                }else{
                    Speaker:printProper("[RLCPT] Locomotive has only one Prime Mover!")
                }
                break
            case ".setair",
                if(0){
                    MainRes = Sentence[2,string]:toNumber()
                }else{
                    Speaker:printProper("[RLCPT] This command has been disabled.")
                }
                hideChat(1)
                break
            case ".handbrake",
                if(MU_Master){
                    if(MPH<5){
                        abRest(E:getConstraints())
                        Pod:soundPlay(3,1,"buttons/lever4.wav")
                        Speaker:printProper("[RLCPT] Train Handbrakes Tightened!")
                    }
                    hideChat(1)
                }
                break
                
            case ".count",
                if(MU_Master){
                    local LocoCount = Sentence[2,string]:toNumber()
                    if(LocoCount==0){
                        LocoCount = 1
                    }
                    Speaker:printProper("[RLCPT] Your train is pulling "+(CarCount+1-LocoCount)+" Car(s) with "+LocoCount+" Locomotive(s).")
                
                    hideChat(1)
                }
                break
                
            case ".weight",
                if(MU_Master){
                    local TotalKGR = 0
                    local WeightProps = E:getConstraints()
                    foreach(K,V:entity=WeightProps){
                        TotalKGR += V:mass()
                    }
                    local TotalKG = TotalKGR*2
                    local TrailingLB = toUnit("lb",TotalKG) - (Weight + FrontPlugIn[15,number] + RearPlugIn[15,number])
                    local TrailingT = round(TrailingLB/2000,1)
                    
                    local SCE = round(fromUnit("lb",TrailingLB)/50000,1)
                    
                    Speaker:printProper("[RLCPT] Your train is pulling "+TrailingT:toString()+" Trailing Tons ("+SCE:toString()+" SCE).")
                    hideChat(1)
                }
                break
            
            case ".hpt",
                if(MU_Master){
                    local TotalKGR = 0
                    local WeightProps = E:getConstraints()
                    foreach(K,V:entity=WeightProps){
                        TotalKGR += V:mass()
                    }
                    local TotalKG = TotalKGR*2
                    local TrailingLB = toUnit("lb",TotalKG) - (Weight + FrontPlugIn[15,number] + RearPlugIn[15,number])
                    local TrailingT = TrailingLB/2000
                    
                    local TotalHP = 0
                    if(Sentence[2,string]!=""){
                        for(N=2,Sentence:count()){
                            TotalHP += Sentence[2,string]:toNumber()
                        }
                    }else{
                        TotalHP = Horsepower + FrontPlugIn[7,number] + RearPlugIn[7,number]
                    }
                    local HPT = round(TotalHP/TrailingT,2)
                    
                    Speaker:printProper("[RLCPT] Your train is supplying "+HPT:toString()+" Horsepower per Trailing Ton ("+TotalHP:toString()+" HP, "+round(TrailingT,1):toString()+" TT).")
                    hideChat(1)
                }
                break
            case ".transitions",
                if(MU_Master){
                    if(TransitionMode & TransitionControlType){
                        local PrintString = "[RLCPT] This Locomotive has Automatic Transitions at "
                        for(N=1,TransitionNotches-1){
                            PrintString += (round(TransitionThresholds[N+1,number]):toString())
                            if(N<TransitionNotches-1){
                                PrintString += ", "
                            }else{
                                PrintString += " MPH."
                            }
                        }
                        
                        Speaker:printProper(PrintString)
                    }elseif(TransitionMode & !TransitionControlType){
                        local PrintString = "[RLCPT] This Locomotive has Manual Transition! Shift at "
                            for(N=1,TransitionNotches-1){
                                PrintString += (round(TransitionThresholds[N+1,number]):toString())
                                if(N<TransitionNotches-1){
                                    PrintString += ", "
                                }else{
                                    PrintString += " MPH."
                                }
                            }
                        Speaker:printProper(PrintString)
                    }elseif(!TransitionMode){
                        Speaker:printProper("[RLCPT] This Locomotive has no transitions!")
                    }
                }
                hideChat(1)
                break
            case ".weightreset",
                setWeight(W,SpanBolsters,Trucks,Weight)
                Speaker:printProper("[RLCPT] Locomotive weights reset.")
                hideChat(1)
                break
            case ".switching",
                
                if(Sentence[2,string]==""){
                    SwitchingMode = !SwitchingMode
                }else{
                    SwitchingMode = Sentence[2,string]=="1"
                }
                Speaker:printProper(SwitchingMode ? "[RLCPT] Trainline brakes cut out (Switching Mode engaged)!" : "[RLCPT] Trainline brakes cut in (Switching Mode disengaged)!")
            
                hideChat(1)
                break
            case ".graduatedrelease",
                if(Sentence[2,string]==""){
                    GraduatedRelease = !GraduatedRelease
                }else{
                    GraduatedRelease = Sentence[2,string]:toNumber()
                }
                
                print("[RLCPT] Graduated Release Cap and Retainer Valves set to " + (GraduatedRelease ? "GRADUATED RELEASE." : "DIRECT RELEASE."))
                hideChat(1)
                break
            case ".railtype",
                local RT = Sentence[2,string]
                if(RT=="welded"){
                    RailType = 0
                    if(RollQ){
                        W:soundPlay(7,0,RollSoundWelded)
                    }
                    Speaker:printProper("[RLCPT] You are now riding on welded rails.")
                }elseif(RT=="jointed"){
                    RailType = 1
                    if(RollQ){
                        W:soundPlay(7,0,RollSoundJointed)
                    }
                    Speaker:printProper("[RLCPT] You are now riding on jointed rails.")
                }else{
                    Speaker:printProper("[RLCPT] You are currently riding on "+(RailType ? "jointed" : "welded")+" rails.")
                }
                hideChat(1)
                break
            default,
                if(CMD:index(1)=="."){
                    #print("Sorry, \""+CMD+"\" is not a valid command, but we've hidden it anyway to spare you the embarrassment!")
                    hideChat(1)
                }
                break
        }
    }
    
}
#if(clkName()!="clk"){print(clkName())}
